[
  {
    "id": "1",
    "text": "¿Qué widget permite crear una lista desplazable de elementos?",
    "options": [
      {
        "id": "A",
        "text": "Container"
      },
      {
        "id": "B",
        "text": "ListView"
      },
      {
        "id": "C",
        "text": "Row"
      },
      {
        "id": "D",
        "text": "Column"
      }
    ],
    "correctOptionId": "B",
    "explanation": "ListView es un widget que permite mostrar una lista desplazable de hijos uno tras otro en la dirección de desplazamiento.",
    "category": "Widgets"
  },
  {
    "id": "2",
    "text": "¿Cuál es la diferencia principal entre StatelessWidget y StatefulWidget?",
    "options": [
      {
        "id": "A",
        "text": "No hay diferencia, se pueden usar indistintamente"
      },
      {
        "id": "B",
        "text": "StatelessWidget es más eficiente y siempre debe preferirse"
      },
      {
        "id": "C",
        "text": "StatefulWidget almacena estado mientras que StatelessWidget no"
      },
      {
        "id": "D",
        "text": "StatelessWidget es para diseño y StatefulWidget para lógica"
      }
    ],
    "correctOptionId": "C",
    "explanation": "La principal diferencia es que StatefulWidget puede mantener un estado mutable que puede cambiar durante la vida del widget, mientras que StatelessWidget no almacena ningún estado y su apariencia no puede cambiar una vez construido.",
    "category": "Fundamentos"
  },
  {
    "id": "3",
    "text": "¿Cuál de los siguientes NO es un widget de posicionamiento en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Align"
      },
      {
        "id": "B",
        "text": "Stack"
      },
      {
        "id": "C",
        "text": "Positioned"
      },
      {
        "id": "D",
        "text": "Modifier"
      }
    ],
    "correctOptionId": "D",
    "explanation": "Modifier no es un widget de Flutter. Align, Stack y Positioned son widgets utilizados para el posicionamiento de elementos en la interfaz.",
    "category": "Widgets"
  },
  {
    "id": "4",
    "text": "¿Qué hace el siguiente código?",
    "codeSnippet": "void main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Mi App')),\n        body: const Center(child: Text('Hola Mundo')),\n      ),\n    );\n  }\n}",
    "options": [
      {
        "id": "A",
        "text": "Crea una aplicación iOS nativa"
      },
      {
        "id": "B",
        "text": "Muestra un error porque faltan importaciones"
      },
      {
        "id": "C",
        "text": "Crea una aplicación Flutter con un texto centrado"
      },
      {
        "id": "D",
        "text": "Define una clase que no puede ser instanciada"
      }
    ],
    "correctOptionId": "C",
    "explanation": "El código crea una aplicación Flutter con MaterialApp como raíz, un Scaffold como estructura principal, un AppBar en la parte superior y un texto centrado que dice 'Hola Mundo' en el cuerpo de la aplicación.",
    "category": "Fundamentos"
  },
  {
    "id": "5",
    "text": "¿Qué método se utiliza para actualizar el estado de un StatefulWidget?",
    "options": [
      {
        "id": "A",
        "text": "updateState()"
      },
      {
        "id": "B",
        "text": "setState()"
      },
      {
        "id": "C",
        "text": "refresh()"
      },
      {
        "id": "D",
        "text": "rebuild()"
      }
    ],
    "correctOptionId": "B",
    "explanation": "setState() es el método que se utiliza para notificar al framework que el estado interno ha cambiado y que se debe reconstruir la interfaz de usuario para reflejar los cambios.",
    "category": "Fundamentos"
  },
  {
    "id": "6",
    "text": "¿Qué es un BuildContext en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Una clase para construir interfaces de usuario"
      },
      {
        "id": "B",
        "text": "Un objeto que contiene información sobre la ubicación de un widget en el árbol de widgets"
      },
      {
        "id": "C",
        "text": "Una función que retorna widgets"
      },
      {
        "id": "D",
        "text": "Un método para compilar código Flutter"
      }
    ],
    "correctOptionId": "B",
    "explanation": "BuildContext es un objeto que contiene información sobre la ubicación de un widget en el árbol de widgets. Se utiliza para acceder a temas, MediaQuery, Navigator y otros datos desde el árbol.",
    "category": "Fundamentos"
  },
  {
    "id": "7",
    "text": "¿Cuál es la diferencia entre hot reload y hot restart en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "No hay diferencia, son términos intercambiables"
      },
      {
        "id": "B",
        "text": "Hot reload actualiza la UI conservando el estado, hot restart reinicia completamente la aplicación"
      },
      {
        "id": "C",
        "text": "Hot reload es más lento que hot restart"
      },
      {
        "id": "D",
        "text": "Hot restart solo funciona en modo de depuración"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Hot reload inyecta el código actualizado en la máquina virtual de Dart y Flutter reconstruye el árbol de widgets conservando el estado. Hot restart reinicia completamente la aplicación, perdiendo todo el estado.",
    "category": "Configuración"
  },
  {
    "id": "8",
    "text": "¿Qué método se llama automáticamente cuando un StatefulWidget se inserta en el árbol?",
    "options": [
      {
        "id": "A",
        "text": "build()"
      },
      {
        "id": "B",
        "text": "initState()"
      },
      {
        "id": "C",
        "text": "createState()"
      },
      {
        "id": "D",
        "text": "didChangeDependencies()"
      }
    ],
    "correctOptionId": "C",
    "explanation": "El método createState() se llama automáticamente cuando un StatefulWidget se inserta en el árbol. Este método debe sobrescribirse para crear el objeto State asociado al StatefulWidget.",
    "category": "Fundamentos"
  },
  {
    "id": "9",
    "text": "¿Qué widget deberías usar para centrar un hijo horizontalmente en la pantalla?",
    "options": [
      {
        "id": "A",
        "text": "Row con mainAxisAlignment.center"
      },
      {
        "id": "B",
        "text": "Column con crossAxisAlignment.center"
      },
      {
        "id": "C",
        "text": "Center"
      },
      {
        "id": "D",
        "text": "Container con alignment: Alignment.center"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Para centrar un hijo horizontalmente, debes usar un Row con mainAxisAlignment.center. El Center widget centra su hijo tanto horizontal como verticalmente.",
    "category": "Widgets"
  },
  {
    "id": "10",
    "text": "¿Cuál es la función principal de un GlobalKey en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Permitir que un widget sea único en toda la aplicación"
      },
      {
        "id": "B",
        "text": "Encriptar datos sensibles en la aplicación"
      },
      {
        "id": "C",
        "text": "Optimizar el rendimiento de la aplicación"
      },
      {
        "id": "D",
        "text": "Configurar el tema global de la aplicación"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Un GlobalKey proporciona acceso a un widget específico y su estado, permitiendo identificarlo de manera única en toda la aplicación. Esto permite acceder a métodos y propiedades de sus State asociados desde cualquier parte del código.",
    "category": "Fundamentos"
  },
  {
    "id": "11",
    "text": "¿Qué método se utiliza para manejar la navegación entre pantallas en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Navigator.go()"
      },
      {
        "id": "B",
        "text": "Navigator.push()"
      },
      {
        "id": "C",
        "text": "Navigator.navigate()"
      },
      {
        "id": "D",
        "text": "Navigator.moveTo()"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Navigator.push() es el método que se utiliza para navegar a una nueva pantalla/página. Recibe un BuildContext y una ruta (Route) como parámetros.",
    "category": "Navegación"
  },
  {
    "id": "12",
    "text": "¿Cuál widget deberías usar para crear un diseño responsivo que se adapte a diferentes tamaños de pantalla?",
    "options": [
      {
        "id": "A",
        "text": "Container"
      },
      {
        "id": "B",
        "text": "Flexible"
      },
      {
        "id": "C",
        "text": "LayoutBuilder"
      },
      {
        "id": "D",
        "text": "SizedBox"
      }
    ],
    "correctOptionId": "C",
    "explanation": "LayoutBuilder proporciona las restricciones de diseño impuestas por el padre y permite crear widgets diferentes basados en el espacio disponible, lo que lo hace ideal para diseños responsivos.",
    "category": "Widgets"
  },
  {
    "id": "13",
    "text": "¿Qué es el widget Scaffold en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget para crear formularios"
      },
      {
        "id": "B",
        "text": "Una implementación de Material Design que proporciona una estructura básica para una pantalla"
      },
      {
        "id": "C",
        "text": "Un widget para gestionar el ciclo de vida de la aplicación"
      },
      {
        "id": "D",
        "text": "Un contenedor para almacenar datos de estado"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Scaffold es un widget que implementa la estructura básica de diseño visual de Material Design. Proporciona APIs para mostrar drawers, snack bars, y bottom sheets.",
    "category": "Widgets"
  },
  {
    "id": "16",
    "text": "¿Qué hace el método dispose() en un State de StatefulWidget?",
    "options": [
      {
        "id": "A",
        "text": "Elimina widgets no utilizados"
      },
      {
        "id": "B",
        "text": "Libera recursos cuando el widget se elimina del árbol"
      },
      {
        "id": "C",
        "text": "Restablece el estado a sus valores iniciales"
      },
      {
        "id": "D",
        "text": "Actualiza automáticamente la UI"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El método dispose() se llama cuando el State se elimina permanentemente del árbol. Es el lugar adecuado para limpiar recursos como suscripciones a streams, controladores de animación, o FocusNode que podrían causar fugas de memoria.",
    "category": "Fundamentos"
  },
  {
    "id": "17",
    "text": "¿Qué es un FutureBuilder en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget que construye su árbol de widgets en el futuro"
      },
      {
        "id": "B",
        "text": "Un widget que construye diferentes widgets según el estado de un Future"
      },
      {
        "id": "C",
        "text": "Una clase para crear tareas asíncronas"
      },
      {
        "id": "D",
        "text": "Una herramienta para programar la construcción de widgets"
      }
    ],
    "correctOptionId": "B",
    "explanation": "FutureBuilder es un widget que toma un Future y un builder que construye diferentes widgets según el estado del Future (en espera, completado o con error).",
    "category": "Asincronía"
  },
  {
    "id": "18",
    "text": "¿Cuál es la diferencia entre SizedBox y Container?",
    "options": [
      {
        "id": "A",
        "text": "SizedBox solo puede tener un tamaño fijo mientras que Container puede expandirse"
      },
      {
        "id": "B",
        "text": "Container tiene más propiedades de estilo como decoration, mientras SizedBox es más simple"
      },
      {
        "id": "C",
        "text": "SizedBox solo puede contener un widget Text"
      },
      {
        "id": "D",
        "text": "No hay diferencia, son widgets equivalentes"
      }
    ],
    "correctOptionId": "B",
    "explanation": "SizedBox es un widget simple que impone restricciones de tamaño a su hijo. Container es más complejo y ofrece propiedades adicionales como decoration, padding, margin, color, etc.",
    "category": "Widgets"
  },
  {
    "id": "19",
    "text": "¿Qué es un StreamBuilder en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget para construir animaciones fluidas"
      },
      {
        "id": "B",
        "text": "Un widget que construye diferentes widgets según los valores emitidos por un Stream"
      },
      {
        "id": "C",
        "text": "Una clase para crear flujos de datos"
      },
      {
        "id": "D",
        "text": "Una herramienta para transmitir datos entre widgets"
      }
    ],
    "correctOptionId": "B",
    "explanation": "StreamBuilder es un widget que toma un Stream y un builder que construye diferentes widgets según los valores emitidos por el Stream a lo largo del tiempo.",
    "category": "Asincronía"
  },
  {
    "id": "21",
    "text": "¿Qué widget se utiliza para crear un botón con un icono en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "RaisedButton"
      },
      {
        "id": "B",
        "text": "IconButton"
      },
      {
        "id": "C",
        "text": "FlatIconButton"
      },
      {
        "id": "D",
        "text": "ButtonIcon"
      }
    ],
    "correctOptionId": "B",
    "explanation": "IconButton es un widget específico para crear botones con iconos en Flutter. Permite definir un icono y una acción a ejecutar cuando se pulsa.",
    "category": "Widgets"
  },
  {
    "id": "22",
    "text": "¿Qué método se debe implementar para definir la interfaz de usuario en un widget de Flutter?",
    "options": [
      {
        "id": "A",
        "text": "create()"
      },
      {
        "id": "B",
        "text": "render()"
      },
      {
        "id": "C",
        "text": "build()"
      },
      {
        "id": "D",
        "text": "initialize()"
      }
    ],
    "correctOptionId": "C",
    "explanation": "El método build() debe implementarse en todos los widgets de Flutter para definir la estructura de la interfaz de usuario. Es donde se definen los widgets que componen la interfaz.",
    "category": "Fundamentos"
  },
  {
    "id": "23",
    "text": "En Dart, ¿qué operador se utiliza para una verificación de nulos más segura?",
    "options": [
      {
        "id": "A",
        "text": "?."
      },
      {
        "id": "B",
        "text": "!!"
      },
      {
        "id": "C",
        "text": "??"
      },
      {
        "id": "D",
        "text": "$$"
      }
    ],
    "correctOptionId": "A",
    "explanation": "El operador ?. (operador de acceso seguro) se utiliza para realizar una verificación de nulos más segura. Si el objeto es nulo, la expresión completa evalúa a nulo en lugar de lanzar una excepción.",
    "category": "Dart"
  },
  {
    "id": "24",
    "text": "¿Cuál es la mejor forma de implementar una lista infinita (lazy loading) en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "ListWidget"
      },
      {
        "id": "B",
        "text": "ListView"
      },
      {
        "id": "C",
        "text": "InfiniteList"
      },
      {
        "id": "D",
        "text": "LazyList"
      }
    ],
    "correctOptionId": "B",
    "explanation": "ListView.builder es ideal para listas potencialmente infinitas ya que construye los elementos solo cuando son visibles en pantalla, lo que mejora significativamente el rendimiento para listas grandes.",
    "category": "Widgets"
  },
  {
    "id": "26",
    "text": "¿Qué widget proporciona una forma eficiente de mostrar un gran número de elementos en una lista?",
    "options": [
      {
        "id": "A",
        "text": "Column"
      },
      {
        "id": "B",
        "text": "ListView"
      },
      {
        "id": "C",
        "text": "Row"
      },
      {
        "id": "D",
        "text": "Stack"
      }
    ],
    "correctOptionId": "B",
    "explanation": "ListView es un widget que permite desplazarse por una lista de elementos. Puede construir sus elementos de forma perezosa (lazy) usando ListView.builder, lo que lo hace eficiente para mostrar grandes conjuntos de datos.",
    "category": "Widgets"
  },
  {
    "id": "27",
    "text": "¿Cuál es la función principal del widget Scaffold en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Proporcionar una estructura visual básica siguiendo el Material Design"
      },
      {
        "id": "B",
        "text": "Gestionar las animaciones en la aplicación"
      },
      {
        "id": "C",
        "text": "Almacenar datos persistentes"
      },
      {
        "id": "D",
        "text": "Optimizar el rendimiento de la aplicación"
      }
    ],
    "correctOptionId": "A",
    "explanation": "El widget Scaffold implementa la estructura visual básica del Material Design. Proporciona APIs para mostrar drawers, snack bars y bottom sheets.",
    "category": "Widgets"
  },
  {
    "id": "28",
    "text": "¿Qué widget se utiliza para crear un menú lateral deslizable en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "SidePanel"
      },
      {
        "id": "B",
        "text": "SlideMenu"
      },
      {
        "id": "C",
        "text": "Drawer"
      },
      {
        "id": "D",
        "text": "SideBar"
      }
    ],
    "correctOptionId": "C",
    "explanation": "El widget Drawer se utiliza para crear un panel lateral deslizable que generalmente contiene opciones de navegación. Se usa como propiedad del widget Scaffold.",
    "category": "Widgets"
  },
  {
    "id": "29",
    "text": "En Dart, ¿qué tipo de datos se utiliza para representar una secuencia de caracteres?",
    "options": [
      {
        "id": "A",
        "text": "char[]"
      },
      {
        "id": "B",
        "text": "String"
      },
      {
        "id": "C",
        "text": "Text"
      },
      {
        "id": "D",
        "text": "Characters"
      }
    ],
    "correctOptionId": "B",
    "explanation": "En Dart, el tipo String se utiliza para representar una secuencia de caracteres. Es inmutable, lo que significa que una vez creado no puede ser modificado.",
    "category": "Dart"
  },
  {
    "id": "30",
    "text": "¿Cuál es el propósito del widget SafeArea en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Prevenir acceso no autorizado a la aplicación"
      },
      {
        "id": "B",
        "text": "Evitar que el contenido sea recortado por características del dispositivo como el notch o bordes redondeados"
      },
      {
        "id": "C",
        "text": "Cifrar datos sensibles en la aplicación"
      },
      {
        "id": "D",
        "text": "Proporcionar un área de seguridad para widgets críticos"
      }
    ],
    "correctOptionId": "B",
    "explanation": "SafeArea es un widget que inserta su hijo con suficiente padding para evitar intrusiones del sistema operativo, como la muesca (notch) en la parte superior de algunos dispositivos iOS o la barra de navegación en Android.",
    "category": "Widgets"
  },
  {
    "id": "31",
    "text": "¿Qué método se utiliza para realizar navegación a una nueva pantalla y reemplazar la actual en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Navigator.push()"
      },
      {
        "id": "B",
        "text": "Navigator.replace()"
      },
      {
        "id": "C",
        "text": "Navigator.pushReplacement()"
      },
      {
        "id": "D",
        "text": "Navigator.goto()"
      }
    ],
    "correctOptionId": "C",
    "explanation": "Navigator.pushReplacement() se utiliza para navegar a una nueva pantalla y reemplazar la actual en la pila de navegación, lo que significa que el usuario no podrá volver a la pantalla anterior con el botón atrás.",
    "category": "Navegación"
  },
  {
    "id": "32",
    "text": "¿Qué widget se debe utilizar para crear una cuadrícula de un número fijo de elementos en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "GridView.count"
      },
      {
        "id": "B",
        "text": "ListView.grid"
      },
      {
        "id": "C",
        "text": "Column con Row anidadas"
      },
      {
        "id": "D",
        "text": "TableView"
      }
    ],
    "correctOptionId": "A",
    "explanation": "GridView.count crea una cuadrícula con un número fijo de elementos en la dirección transversal. Es ideal para mostrar elementos en formato de rejilla con tamaño fijo.",
    "category": "Widgets"
  },
  {
    "id": "33",
    "text": "¿Cuál es la diferencia entre const y final en Dart?",
    "options": [
      {
        "id": "A",
        "text": "No hay diferencia, son sinónimos"
      },
      {
        "id": "B",
        "text": "const es para variables de clase y final para variables locales"
      },
      {
        "id": "C",
        "text": "final se establece en tiempo de ejecución, mientras que const debe ser conocido en tiempo de compilación"
      },
      {
        "id": "D",
        "text": "const solo se puede usar en funciones, mientras que final solo en clases"
      }
    ],
    "correctOptionId": "C",
    "explanation": "En Dart, final indica que la variable solo puede ser asignada una vez y su valor es inmutable, pero puede ser determinado en tiempo de ejecución. const debe ser conocido en tiempo de compilación y también crea objetos inmutables.",
    "category": "Dart"
  },
  {
    "id": "34",
    "text": "¿Qué widget se usa para crear una barra de navegación inferior en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "NavBar"
      },
      {
        "id": "B",
        "text": "BottomNavigationBar"
      },
      {
        "id": "C",
        "text": "FooterMenu"
      },
      {
        "id": "D",
        "text": "TabBar"
      }
    ],
    "correctOptionId": "B",
    "explanation": "BottomNavigationBar es un widget de Material Design que muestra de 3 a 5 destinos en la parte inferior de la pantalla, permitiendo al usuario navegar entre diferentes secciones de la aplicación.",
    "category": "Widgets"
  },
  {
    "id": "35",
    "text": "¿Qué método se utiliza para ejecutar código asíncrono en Dart?",
    "options": [
      {
        "id": "A",
        "text": "execute()"
      },
      {
        "id": "B",
        "text": "runAsync()"
      },
      {
        "id": "C",
        "text": "await"
      },
      {
        "id": "D",
        "text": "parallel()"
      }
    ],
    "correctOptionId": "C",
    "explanation": "El operador await se utiliza en funciones async para pausar la ejecución hasta que se complete una Future. Esto permite escribir código asíncrono de manera que parezca síncrono, facilitando su comprensión.",
    "category": "Asincronía"
  },
  {
    "id": "36",
    "text": "¿Qué es un StatelessWidget en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget que no puede tener hijos"
      },
      {
        "id": "B",
        "text": "Un widget cuyo estado puede cambiar durante su vida útil"
      },
      {
        "id": "C",
        "text": "Un widget que describe parte de la interfaz de usuario que no depende de nada más que de la configuración de inicialización"
      },
      {
        "id": "D",
        "text": "Un widget que solo se puede usar en la raíz de la aplicación"
      }
    ],
    "correctOptionId": "C",
    "explanation": "Un StatelessWidget es un widget que describe parte de la interfaz de usuario que no depende de nada más que de la configuración de inicialización y no puede cambiar durante la vida útil del widget.",
    "category": "Fundamentos"
  },
  {
    "id": "37",
    "text": "¿Qué función tiene el widget GestureDetector en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Detectar errores en tiempo de ejecución"
      },
      {
        "id": "B",
        "text": "Detectar gestos como toques, arrastres, pellizcos, etc."
      },
      {
        "id": "C",
        "text": "Crear animaciones basadas en gestos"
      },
      {
        "id": "D",
        "text": "Mejorar el rendimiento de la aplicación"
      }
    ],
    "correctOptionId": "B",
    "explanation": "GestureDetector es un widget que detecta gestos como toques, arrastres, pellizcos, etc. Permite agregar interactividad a otros widgets que normalmente no responden a la entrada del usuario.",
    "category": "Widgets"
  },
  {
    "id": "38",
    "text": "¿Qué es un Future en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Una clase para planificar tareas en el futuro"
      },
      {
        "id": "B",
        "text": "Un objeto que representa el resultado de una operación asíncrona"
      },
      {
        "id": "C",
        "text": "Un tipo especial de función que se ejecuta después de un delay"
      },
      {
        "id": "D",
        "text": "Una interfaz para implementar operaciones de larga duración"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Un Future es un objeto que representa el resultado de una operación asíncrona. Puede contener un valor o un error, y permite trabajar con operaciones como peticiones de red o acceso a bases de datos sin bloquear la ejecución.",
    "category": "Asincronía"
  },
  {
    "id": "39",
    "text": "¿Qué widget se usa para crear un menú desplegable en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "DropdownMenu"
      },
      {
        "id": "B",
        "text": "PopupMenu"
      },
      {
        "id": "C",
        "text": "DropdownButton"
      },
      {
        "id": "D",
        "text": "SelectMenu"
      }
    ],
    "correctOptionId": "C",
    "explanation": "DropdownButton es un widget de Material Design que muestra un menú desplegable cuando se pulsa, permitiendo al usuario seleccionar un valor de una lista de opciones.",
    "category": "Widgets"
  },
  {
    "id": "40",
    "text": "¿Cuál es la forma correcta de definir un constructor en Dart?",
    "options": [
      {
        "id": "A",
        "text": "constructor MiClase() { }"
      },
      {
        "id": "B",
        "text": "MiClase.constructor() { }"
      },
      {
        "id": "C",
        "text": "MiClase() { }"
      },
      {
        "id": "D",
        "text": "new MiClase() { }"
      }
    ],
    "correctOptionId": "C",
    "explanation": "En Dart, los constructores se definen utilizando el nombre de la clase seguido de paréntesis y un bloque de código. También es posible definir constructores con nombre utilizando NombreClase.nombreConstructor().",
    "category": "Dart"
  },
  {
    "id": "41",
    "text": "¿Qué widget se utiliza para crear un campo de texto editable en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "InputField"
      },
      {
        "id": "B",
        "text": "EditText"
      },
      {
        "id": "C",
        "text": "TextField"
      },
      {
        "id": "D",
        "text": "TextInput"
      }
    ],
    "correctOptionId": "C",
    "explanation": "TextField es el widget utilizado en Flutter para crear campos de texto editables. Permite a los usuarios ingresar texto y ofrece numerosas opciones de personalización como decoración, validación y control de entrada.",
    "category": "Widgets"
  },
  {
    "id": "42",
    "text": "¿Qué es un mixin en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Una clase que solo puede ser instanciada una vez"
      },
      {
        "id": "B",
        "text": "Una forma de reutilizar código en múltiples jerarquías de clases"
      },
      {
        "id": "C",
        "text": "Un método especial para mezclar widgets"
      },
      {
        "id": "D",
        "text": "Una función que combina múltiples streams"
      }
    ],
    "correctOptionId": "B",
    "explanation": "En Dart, un mixin es una forma de reutilizar el código de una clase en múltiples jerarquías de clases. Los mixins se definen usando la palabra clave 'mixin' y se aplican a una clase usando 'with'.",
    "category": "Dart"
  },
  {
    "id": "43",
    "text": "¿Cuál es el propósito del widget Hero en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Crear un widget destacado visualmente"
      },
      {
        "id": "B",
        "text": "Añadir superpoderes a la aplicación"
      },
      {
        "id": "C",
        "text": "Definir el widget principal de la aplicación"
      },
      {
        "id": "D",
        "text": "Crear una animación fluida entre pantallas para un widget"
      }
    ],
    "correctOptionId": "D",
    "explanation": "El widget Hero se utiliza para crear una animación de transición entre pantallas para un elemento. Marca un widget en una pantalla para que se anime hacia su posición en la siguiente pantalla, creando una experiencia de navegación fluida.",
    "category": "Widgets"
  },
  {
    "id": "44",
    "text": "¿Qué es ListTile y en qué contexto se usa comúnmente?",
    "options": [
      {
        "id": "A",
        "text": "Un widget para mostrar elementos horizontales en una tabla"
      },
      {
        "id": "B",
        "text": "Un widget que representa una fila con un formato predefinido para usar en listas y menús"
      },
      {
        "id": "C",
        "text": "Un widget para crear títulos en una aplicación"
      },
      {
        "id": "D",
        "text": "Un widget que contiene una lista de botones"
      }
    ],
    "correctOptionId": "B",
    "explanation": "ListTile es un widget que representa una fila con un formato predefinido, típicamente usado en ListView, Drawer y otros componentes que muestran listas. Proporciona una estructura con espaciado para leading (generalmente un ícono), title, subtitle y trailing widgets.",
    "category": "Widgets"
  },
  {
    "id": "45",
    "text": "¿Qué es el paquete http en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un paquete para crear servidores HTTP"
      },
      {
        "id": "B",
        "text": "Un paquete para realizar peticiones HTTP"
      },
      {
        "id": "C",
        "text": "Un paquete integrado en Flutter Core"
      },
      {
        "id": "D",
        "text": "web_requests"
      }
    ],
    "correctOptionId": "B",
    "explanation": "La biblioteca 'http' es la forma estándar de realizar peticiones HTTP en aplicaciones Flutter. Proporciona clases y funciones para realizar solicitudes GET, POST, PUT, DELETE, etc.",
    "category": "Librerías"
  },
  {
    "id": "47",
    "text": "¿Qué es un Stream en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Una secuencia de datos asíncronos"
      },
      {
        "id": "B",
        "text": "Un tipo especial de Future"
      },
      {
        "id": "C",
        "text": "Una función que se ejecuta en segundo plano"
      },
      {
        "id": "D",
        "text": "Un método para transmitir vídeo"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Un Stream en Dart es una secuencia de datos asíncronos. A diferencia de Future, que proporciona un solo valor asíncrono, un Stream puede proporcionar múltiples valores a lo largo del tiempo.",
    "category": "Asincronía"
  },
  {
    "id": "48",
    "text": "¿Qué biblioteca se utiliza para realizar peticiones HTTP en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "flutter_http"
      },
      {
        "id": "B",
        "text": "http"
      },
      {
        "id": "C",
        "text": "net"
      },
      {
        "id": "D",
        "text": "web_requests"
      }
    ],
    "correctOptionId": "B",
    "explanation": "La biblioteca 'http' es la forma estándar de realizar peticiones HTTP en aplicaciones Flutter. Proporciona clases y funciones para realizar solicitudes GET, POST, PUT, DELETE, etc.",
    "category": "Librerías"
  },
  {
    "id": "50",
    "text": "¿Cuál es el propósito del widget MediaQuery en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Reproducir archivos multimedia"
      },
      {
        "id": "B",
        "text": "Consultar el tamaño de la pantalla y otras características del dispositivo"
      },
      {
        "id": "C",
        "text": "Gestionar consultas a la base de datos"
      },
      {
        "id": "D",
        "text": "Realizar peticiones HTTP"
      }
    ],
    "correctOptionId": "B",
    "explanation": "MediaQuery permite a los widgets obtener información sobre el entorno actual del dispositivo, como el tamaño de la pantalla, la orientación, la densidad de píxeles, etc., facilitando la creación de interfaces adaptativas.",
    "category": "Widgets"
  },
  {
    "id": "51",
    "text": "¿Qué permite hacer el widget InheritedWidget en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Crear clases que heredan propiedades de otras clases"
      },
      {
        "id": "B",
        "text": "Proporcionar datos a widgets descendientes sin pasarlos explícitamente"
      },
      {
        "id": "C",
        "text": "Heredar el estilo visual de su widget padre"
      },
      {
        "id": "D",
        "text": "Garantizar que un widget solo se dibuje una vez"
      }
    ],
    "correctOptionId": "B",
    "explanation": "InheritedWidget es un tipo de widget que permite propagar datos eficientemente por el árbol de widgets, permitiendo que los widgets descendientes accedan a esos datos sin necesidad de pasarlos explícitamente a través de constructores.",
    "category": "Fundamentos"
  },
  {
    "id": "52",
    "text": "¿Qué es un Future<void> en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Un Future que nunca se completa"
      },
      {
        "id": "B",
        "text": "Un Future que no retorna ningún valor cuando se completa"
      },
      {
        "id": "C",
        "text": "Un Future que se ejecuta en segundo plano"
      },
      {
        "id": "D",
        "text": "Un tipo especial de Future para operaciones largas"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Un Future<void> es un Future que no retorna ningún valor útil cuando se completa. Se utiliza comúnmente para operaciones asíncronas donde solo nos interesa saber cuándo ha terminado la operación, no su resultado.",
    "category": "Asincronía"
  },
  {
    "id": "54",
    "text": "¿Qué característica proporciona el widget FutureBuilder?",
    "options": [
      {
        "id": "A",
        "text": "Construye widgets basados en el resultado futuro de un cálculo"
      },
      {
        "id": "B",
        "text": "Crea widgets que se renderizarán en el futuro"
      },
      {
        "id": "C",
        "text": "Optimiza el rendimiento de la construcción de widgets"
      },
      {
        "id": "D",
        "text": "Planifica la construcción de widgets para más tarde"
      }
    ],
    "correctOptionId": "A",
    "explanation": "FutureBuilder es un widget que construye a sí mismo basado en la última instantánea de interacción con un Future. Permite mostrar diferentes widgets dependiendo del estado del Future (en espera, completado o con error).",
    "category": "Asincronía"
  },
  {
    "id": "55",
    "text": "¿Cuál es la diferencia entre ListView y SingleChildScrollView en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "ListView solo puede contener un tipo de widget, SingleChildScrollView puede contener varios"
      },
      {
        "id": "B",
        "text": "ListView está optimizado para listas largas, SingleChildScrollView para contenido que apenas excede el tamaño de la pantalla"
      },
      {
        "id": "C",
        "text": "ListView solo permite desplazamiento vertical, SingleChildScrollView permite ambas direcciones"
      },
      {
        "id": "D",
        "text": "No hay diferencia, son aliases del mismo widget"
      }
    ],
    "correctOptionId": "B",
    "explanation": "ListView está optimizado para listas potencialmente infinitas, mientras que SingleChildScrollView está diseñado para contenido que es ligeramente más grande que el espacio visible. ListView recicla los elementos no visibles para mejorar el rendimiento.",
    "category": "Widgets"
  },
  {
    "id": "57",
    "text": "¿Qué es el Hot Reload en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Una técnica para optimizar el rendimiento de la aplicación"
      },
      {
        "id": "B",
        "text": "Una forma de actualizar la UI sin perder el estado actual durante el desarrollo"
      },
      {
        "id": "C",
        "text": "Un método para cargar recursos pesados en segundo plano"
      },
      {
        "id": "D",
        "text": "Una característica que permite a la aplicación funcionar sin conexión a internet"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Hot Reload es una característica de desarrollo de Flutter que permite ver los cambios realizados en el código casi instantáneamente sin perder el estado actual de la aplicación, lo que acelera significativamente el ciclo de desarrollo.",
    "category": "Configuración"
  },
  {
    "id": "58",
    "text": "¿Qué es el widget ExpansionPanel en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un panel que se expande para llenar toda la pantalla"
      },
      {
        "id": "B",
        "text": "Un widget que muestra contenido expandible con una cabecera"
      },
      {
        "id": "C",
        "text": "Un widget que aumenta automáticamente su tamaño"
      },
      {
        "id": "D",
        "text": "Una forma de expandir el número de widgets en una lista"
      }
    ],
    "correctOptionId": "B",
    "explanation": "ExpansionPanel es un widget de Material Design que muestra un contenido expandible con una cabecera. Permite crear listas con secciones que pueden expandirse y contraerse, ideal para mostrar información detallada de manera organizada.",
    "category": "Widgets"
  },
  {
    "id": "59",
    "text": "¿Cuál es la forma correcta de manejar errores en operaciones asíncronas en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Usar bloques try/finally"
      },
      {
        "id": "B",
        "text": "Usar bloques try/catch"
      },
      {
        "id": "C",
        "text": "Usar el método onError()"
      },
      {
        "id": "D",
        "text": "Usar el método handleError()"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El uso de bloques try/catch es la forma estándar de manejar errores en operaciones asíncronas en Dart. En funciones async, se pueden capturar excepciones de Futures directamente con try/catch.",
    "category": "Asincronía"
  },
  {
    "id": "60",
    "text": "¿Qué son los Slivers en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Widgets especiales para crear animaciones fluidas"
      },
      {
        "id": "B",
        "text": "Componentes de bajo nivel para construir widgets personalizados de desplazamiento"
      },
      {
        "id": "C",
        "text": "Un tipo de transición entre pantallas"
      },
      {
        "id": "D",
        "text": "Widgets para renderizar efectos de sombra"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Los Slivers son componentes de desplazamiento de bajo nivel en Flutter que permiten crear comportamientos de desplazamiento personalizados. Widgets como SliverAppBar, SliverList y SliverGrid son ejemplos de slivers que pueden combinarse en un CustomScrollView.",
    "category": "Widgets"
  },
  {
    "id": "61",
    "text": "¿Qué es el widget AspectRatio en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget que muestra imágenes manteniendo su relación de aspecto"
      },
      {
        "id": "B",
        "text": "Un widget que ajusta su hijo a una relación de aspecto específica"
      },
      {
        "id": "C",
        "text": "Un widget que calcula automáticamente la mejor relación de aspecto"
      },
      {
        "id": "D",
        "text": "Un widget que adapta su tamaño a la resolución de la pantalla"
      }
    ],
    "correctOptionId": "B",
    "explanation": "AspectRatio es un widget que intenta ajustar su hijo a una relación de aspecto específica. Es útil para mantener proporciones consistentes en diferentes tamaños de pantalla.",
    "category": "Widgets"
  },
  {
    "id": "62",
    "text": "¿Qué es un Isolate en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Una función que se ejecuta aislada de otras funciones"
      },
      {
        "id": "B",
        "text": "Un widget que no se ve afectado por los cambios de tema"
      },
      {
        "id": "C",
        "text": "Una unidad separada de ejecución que no comparte memoria con el hilo principal"
      },
      {
        "id": "D",
        "text": "Una clase especial que no puede ser extendida"
      }
    ],
    "correctOptionId": "C",
    "explanation": "Un Isolate en Dart es una unidad separada de ejecución similar a un hilo, pero que no comparte memoria con otros isolates. La comunicación entre isolates se realiza a través de mensajes, lo que evita problemas de concurrencia.",
    "category": "Dart"
  },
  {
    "id": "65",
    "text": "¿Qué hace el método initState() en un StatefulWidget?",
    "options": [
      {
        "id": "A",
        "text": "Inicializa las variables de estado cuando el widget se inserta en el árbol"
      },
      {
        "id": "B",
        "text": "Restaura el estado previo del widget"
      },
      {
        "id": "C",
        "text": "Inicializa el widget pero no su estado"
      },
      {
        "id": "D",
        "text": "Crea una nueva instancia del widget"
      }
    ],
    "correctOptionId": "A",
    "explanation": "El método initState() se llama cuando el StatefulWidget se inserta en el árbol por primera vez. Es el lugar ideal para inicializar variables de estado, configurar controladores o suscribirse a Streams antes de que el widget sea renderizado.",
    "category": "Fundamentos"
  },
  {
    "id": "68",
    "text": "¿Qué es el widget Semantics en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget para añadir significado semántico al contenido para accesibilidad"
      },
      {
        "id": "B",
        "text": "Un widget para analizar el significado del texto"
      },
      {
        "id": "C",
        "text": "Un widget para crear interfaces inteligentes"
      },
      {
        "id": "D",
        "text": "Un widget para mejorar SEO en aplicaciones web"
      }
    ],
    "correctOptionId": "A",
    "explanation": "El widget Semantics permite añadir significado semántico al contenido de la aplicación para mejorar la accesibilidad. Proporciona información a tecnologías de asistencia como lectores de pantalla, describiendo qué hace un widget o qué representa.",
    "category": "Widgets"
  },
  {
    "id": "69",
    "text": "¿Qué es el método copyWith en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un método estándar para copiar widgets"
      },
      {
        "id": "B",
        "text": "Un patrón comúnmente implementado para crear una nueva instancia con algunos valores modificados"
      },
      {
        "id": "C",
        "text": "Un método para duplicar el árbol de widgets"
      },
      {
        "id": "D",
        "text": "Una función incorporada para clonar objetos"
      }
    ],
    "correctOptionId": "B",
    "explanation": "copyWith es un patrón comúnmente implementado en clases inmutables para crear una nueva instancia con algunos valores modificados mientras se mantienen otros valores iguales. Es útil para trabajar con estados inmutables en Flutter.",
    "category": "Fundamentos"
  },
  {
    "id": "70",
    "text": "¿Qué es una clase abstracta en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Una clase que no puede ser instanciada directamente"
      },
      {
        "id": "B",
        "text": "Una clase que solo contiene métodos estáticos"
      },
      {
        "id": "C",
        "text": "Una clase que no puede ser extendida"
      },
      {
        "id": "D",
        "text": "Una clase con código ofuscado"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Una clase abstracta en Dart es una clase que no puede ser instanciada directamente, sino que debe ser extendida por otras clases. Puede contener métodos abstractos (sin implementación) que las clases derivadas deben implementar.",
    "category": "Dart"
  },
  {
    "id": "71",
    "text": "¿Qué es el archivo pubspec.yaml en un proyecto Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un archivo de configuración para el servidor de publicación"
      },
      {
        "id": "B",
        "text": "Un archivo que contiene metadatos del proyecto y sus dependencias"
      },
      {
        "id": "C",
        "text": "Un archivo de documentación generado automáticamente"
      },
      {
        "id": "D",
        "text": "Un archivo de caché para optimizar el rendimiento"
      }
    ],
    "correctOptionId": "B",
    "explanation": "pubspec.yaml es un archivo que contiene metadatos sobre un proyecto Flutter, incluidas las dependencias, los activos (assets), las fuentes y otra información que el sistema de paquetes de Dart (pub) utiliza para gestionar el proyecto.",
    "category": "Configuración"
  },
  {
    "id": "73",
    "text": "¿Qué paquete se utiliza comúnmente para almacenar datos persistentes en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "flutter_data"
      },
      {
        "id": "B",
        "text": "shared_preferences"
      },
      {
        "id": "C",
        "text": "persistent_storage"
      },
      {
        "id": "D",
        "text": "flutter_save"
      }
    ],
    "correctOptionId": "B",
    "explanation": "shared_preferences es un paquete comúnmente utilizado para almacenar datos persistentes simples en Flutter. Permite guardar pares clave-valor como booleanos, strings, números y listas en el almacenamiento del dispositivo.",
    "category": "Librerías"
  },
  {
    "id": "75",
    "text": "¿Qué es un Future.delayed en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Un Future que nunca se completa"
      },
      {
        "id": "B",
        "text": "Un Future que se completa después de un tiempo específico"
      },
      {
        "id": "C",
        "text": "Un método para posponer la ejecución de una función asíncrona"
      },
      {
        "id": "D",
        "text": "Una clase para manejar operaciones retrasadas"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Future.delayed crea un Future que se completa después de una duración especificada. Es útil para introducir retrasos intencionales en código asíncrono, como simular operaciones de red o crear efectos de temporización.",
    "category": "Asincronía"
  },
  {
    "id": "76",
    "text": "¿Qué es un SizedBox en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget que cambia de tamaño automáticamente"
      },
      {
        "id": "B",
        "text": "Un widget con un tamaño fijo"
      },
      {
        "id": "C",
        "text": "Un widget para animar cambios de tamaño"
      },
      {
        "id": "D",
        "text": "Un widget que se adapta al tamaño de la pantalla"
      }
    ],
    "correctOptionId": "B",
    "explanation": "SizedBox es un widget que tiene un tamaño específico. Se utiliza para dar dimensiones específicas a un widget hijo o para crear espacios en blanco cuando se usa sin hijos (por ejemplo, como separador).",
    "category": "Widgets"
  },
  {
    "id": "81",
    "text": "¿Qué es el widget Dismissible en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget que se puede cerrar automáticamente"
      },
      {
        "id": "B",
        "text": "Un widget que puede ser eliminado deslizándolo"
      },
      {
        "id": "C",
        "text": "Un widget que desaparece después de un tiempo"
      },
      {
        "id": "D",
        "text": "Un widget que ignora las interacciones del usuario"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Dismissible es un widget que puede ser eliminado deslizándolo, comúnmente utilizado en listas para eliminar elementos con un gesto de deslizar. Permite definir acciones para diferentes direcciones de deslizamiento.",
    "category": "Widgets"
  },
  {
    "id": "82",
    "text": "¿Qué es un mixin en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Una clase que no puede ser instanciada"
      },
      {
        "id": "B",
        "text": "Una forma de reutilizar código en múltiples jerarquías de clases"
      },
      {
        "id": "C",
        "text": "Un tipo especial de constructor"
      },
      {
        "id": "D",
        "text": "Una función que mezcla varios objetos"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Un mixin en Dart es una forma de reutilizar código en múltiples jerarquías de clases. A diferencia de la herencia tradicional, los mixins permiten incluir métodos y propiedades de múltiples clases sin crear una relación de herencia completa.",
    "category": "Dart"
  },
  {
    "id": "83",
    "text": "¿Qué widget se utiliza para crear un indicador de progreso circular en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "CircleIndicator"
      },
      {
        "id": "B",
        "text": "RoundProgressBar"
      },
      {
        "id": "C",
        "text": "CircularProgressIndicator"
      },
      {
        "id": "D",
        "text": "SpinnerWidget"
      }
    ],
    "correctOptionId": "C",
    "explanation": "CircularProgressIndicator es un widget de Material Design que muestra un indicador de progreso circular, útil para indicar que una operación está en curso cuando no se conoce la duración exacta.",
    "category": "Widgets"
  },
  {
    "id": "84",
    "text": "¿Cómo se implementa el patrón Singleton en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Usando una clase estática"
      },
      {
        "id": "B",
        "text": "Con un constructor privado y un método estático para obtener la instancia"
      },
      {
        "id": "C",
        "text": "Con la palabra clave 'singleton'"
      },
      {
        "id": "D",
        "text": "Extendiendo la clase SingletonBase"
      }
    ],
    "correctOptionId": "B",
    "explanation": "En Dart, el patrón Singleton se implementa típicamente con un constructor privado (nombrado con un guion bajo al inicio) y un método estático o getter que devuelve una única instancia de la clase, creándola si no existe.",
    "category": "Dart"
  },
  {
    "id": "87",
    "text": "¿Qué es un ValueListenableBuilder en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget que construye su árbol basado en un ValueNotifier"
      },
      {
        "id": "B",
        "text": "Una clase para construir listas de valores"
      },
      {
        "id": "C",
        "text": "Un constructor especial para ListTile"
      },
      {
        "id": "D",
        "text": "Una herramienta para depurar notificaciones de valor"
      }
    ],
    "correctOptionId": "A",
    "explanation": "ValueListenableBuilder es un widget que escucha un ValueListenable (como ValueNotifier) y reconstruye su árbol de widgets cuando el valor cambia. Es una forma eficiente de actualizar solo las partes de la UI que dependen de un valor específico.",
    "category": "Widgets"
  },
  {
    "id": "88",
    "text": "¿Qué es un enum en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Una clase que enumera sus métodos"
      },
      {
        "id": "B",
        "text": "Un tipo que representa un conjunto fijo de constantes"
      },
      {
        "id": "C",
        "text": "Una función que cuenta elementos"
      },
      {
        "id": "D",
        "text": "Una interfaz para implementar iteradores"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Un enum (enumeración) en Dart es un tipo especial que representa un conjunto fijo de constantes. Es útil para modelar opciones mutuamente excluyentes, como estados, tipos de operaciones o configuraciones.",
    "category": "Dart"
  },
  {
    "id": "89",
    "text": "¿Qué es el widget Visibility en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget que controla la opacidad de sus hijos"
      },
      {
        "id": "B",
        "text": "Un widget que muestra u oculta sus hijos basado en una condición"
      },
      {
        "id": "C",
        "text": "Un widget que hace invisibles los elementos de la interfaz"
      },
      {
        "id": "D",
        "text": "Un widget que detecta cuándo un elemento es visible en pantalla"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Visibility es un widget que muestra u oculta sus hijos basado en una condición booleana. A diferencia de usar operadores condicionales directamente, puede mantener el estado y el espacio de sus hijos incluso cuando están ocultos.",
    "category": "Widgets"
  },
  {
    "id": "91",
    "text": "¿Cuál es la función del widget FittedBox en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Redimensionar su hijo para que se ajuste exactamente a sus dimensiones"
      },
      {
        "id": "B",
        "text": "Crear una caja que se adapta automáticamente a su contenido"
      },
      {
        "id": "C",
        "text": "Escalar y posicionar su hijo dentro de sí mismo según el BoxFit especificado"
      },
      {
        "id": "D",
        "text": "Ajustar el tamaño de la fuente del texto para que se adapte"
      }
    ],
    "correctOptionId": "C",
    "explanation": "FittedBox escala y posiciona su hijo dentro de sí mismo según el BoxFit especificado (como contain, cover, fill, etc.). Es útil para asegurar que un widget se ajuste a un espacio determinado manteniendo proporciones o llenando completamente el espacio.",
    "category": "Widgets"
  },
  {
    "id": "92",
    "text": "¿Qué es una clase extension en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Una clase que extiende otra clase"
      },
      {
        "id": "B",
        "text": "Una forma de añadir funcionalidad a clases existentes sin modificarlas"
      },
      {
        "id": "C",
        "text": "Una clase que solo contiene métodos extendidos"
      },
      {
        "id": "D",
        "text": "Un tipo especial de mixin"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Una extension en Dart es una forma de añadir funcionalidad a clases existentes sin modificar o extender la clase original. Permite agregar nuevos métodos o propiedades a tipos existentes, incluso a tipos básicos como String o int.",
    "category": "Dart"
  },
  {
    "id": "98",
    "text": "¿Cuál es la diferencia entre runApp() y MaterialApp en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "No hay diferencia, son términos intercambiables"
      },
      {
        "id": "B",
        "text": "runApp() es una función que inicia la aplicación, MaterialApp es un widget que configura la aplicación"
      },
      {
        "id": "C",
        "text": "runApp() es para aplicaciones básicas, MaterialApp para aplicaciones complejas"
      },
      {
        "id": "D",
        "text": "runApp() es para desarrollo, MaterialApp para producción"
      }
    ],
    "correctOptionId": "B",
    "explanation": "runApp() es una función que infla un widget dado y lo vincula al árbol de widgets de la pantalla, iniciando efectivamente la aplicación. MaterialApp es un widget que configura varios aspectos de la aplicación, como temas, rutas, localización, etc., siguiendo las directrices de Material Design.",
    "category": "Fundamentos"
  },
  {
    "id": "99",
    "text": "¿Qué es un método factory en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Un método que crea nuevas instancias de una clase"
      },
      {
        "id": "B",
        "text": "Un constructor especial que no siempre crea una nueva instancia"
      },
      {
        "id": "C",
        "text": "Un método para fabricar clases en tiempo de ejecución"
      },
      {
        "id": "D",
        "text": "Un patrón de diseño implementado en el lenguaje"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Un constructor factory en Dart es un tipo especial de constructor que no siempre crea una nueva instancia. Puede devolver una instancia existente, una instancia de una subclase, o calcular valores para la instancia, ofreciendo más flexibilidad que los constructores normales.",
    "category": "Dart"
  },
  {
    "id": "102",
    "text": "¿Cuál de las siguientes afirmaciones es correcta sobre el archivo main.dart en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Es obligatorio en todas las aplicaciones Flutter"
      },
      {
        "id": "B",
        "text": "Es el punto de entrada de la aplicación por convención, pero podría llamarse de otra manera"
      },
      {
        "id": "C",
        "text": "Debe contener exactamente una clase StatefulWidget"
      },
      {
        "id": "D",
        "text": "No puede importar otros archivos Dart"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Por convención, main.dart es el punto de entrada de una aplicación Flutter, pero técnicamente podría llamarse de otra manera configurando el punto de entrada en el sistema de compilación. Lo importante es que contenga una función main() que inicie la aplicación.",
    "category": "Fundamentos"
  },
  {
    "id": "103",
    "text": "¿Qué es el Hot Restart en Flutter y cómo difiere del Hot Reload?",
    "options": [
      {
        "id": "A",
        "text": "Hot Restart recarga toda la aplicación y pierde el estado, mientras que Hot Reload conserva el estado"
      },
      {
        "id": "B",
        "text": "Hot Restart solo está disponible en modo de depuración, mientras que Hot Reload funciona en cualquier modo"
      },
      {
        "id": "C",
        "text": "Hot Restart actualiza solo la UI, mientras que Hot Reload actualiza tanto la UI como la lógica"
      },
      {
        "id": "D",
        "text": "Son términos intercambiables para la misma funcionalidad"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Hot Restart reinicia completamente la aplicación, recompilando todo el código y perdiendo el estado actual. Hot Reload, por otro lado, conserva el estado de la aplicación y solo actualiza la UI basada en los cambios de código realizados, lo que hace que sea más rápido para el desarrollo iterativo.",
    "category": "Configuración"
  },
  {
    "id": "104",
    "text": "¿Cuál es el propósito de una clave (Key) en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Encriptar datos sensibles en la aplicación"
      },
      {
        "id": "B",
        "text": "Identificar widgets específicos en el árbol de widgets para preservar el estado o controlar su actualización"
      },
      {
        "id": "C",
        "text": "Proporcionar acceso a las API del sistema"
      },
      {
        "id": "D",
        "text": "Definir constantes globales en la aplicación"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Las claves (Keys) en Flutter se utilizan para identificar widgets específicos en el árbol de widgets. Ayudan al framework a determinar qué widgets deben preservar su estado cuando cambia la estructura del árbol, y son esenciales cuando se trabaja con listas dinámicas o elementos que cambian de posición.",
    "category": "Fundamentos"
  },
  {
    "id": "105",
    "text": "En Flutter, ¿qué método se utiliza para escribir tests que prueban la interacción del usuario con widgets?",
    "options": [
      {
        "id": "A",
        "text": "Integration tests"
      },
      {
        "id": "B",
        "text": "Unit tests"
      },
      {
        "id": "C",
        "text": "Widget tests"
      },
      {
        "id": "D",
        "text": "UI tests"
      }
    ],
    "correctOptionId": "C",
    "explanation": "Los Widget tests son el tipo de prueba ideal para verificar la interacción del usuario con widgets específicos. Permiten simular toques, gestos y otras interacciones, y verificar que los widgets responden correctamente, sin necesidad de ejecutar toda la aplicación como en los Integration tests.",
    "category": "Widgets"
  },
  {
    "id": "106",
    "text": "¿Qué es el widget Builder en Flutter y cuándo debería usarse?",
    "options": [
      {
        "id": "A",
        "text": "Un widget para construir interfaces de forma dinámica basadas en datos externos"
      },
      {
        "id": "B",
        "text": "Un widget que compila widgets personalizados"
      },
      {
        "id": "C",
        "text": "Un widget que permite crear parte de un árbol de widgets en tiempo de ejecución basado en una función"
      },
      {
        "id": "D",
        "text": "Un widget específico para construir animaciones"
      }
    ],
    "correctOptionId": "C",
    "explanation": "Builder es un widget que permite crear parte de un árbol de widgets en tiempo de ejecución mediante una función builder que recibe un BuildContext. Es útil cuando necesitas acceder a un BuildContext en un nivel específico del árbol de widgets, o cuando quieres crear widgets de forma dinámica basados en condiciones en tiempo de ejecución.",
    "category": "Widgets"
  },
  {
    "id": "107",
    "text": "¿Qué técnica se utiliza para implementar la navegación con rutas nombradas en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Navigator.pushNamed(context, '/rutaNombrada')"
      },
      {
        "id": "B",
        "text": "Router.navigateTo('/rutaNombrada')"
      },
      {
        "id": "C",
        "text": "Scaffold.navigateNamed('/rutaNombrada')"
      },
      {
        "id": "D",
        "text": "AppRoute.push('/rutaNombrada')"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Navigator.pushNamed(context, '/rutaNombrada') es el método utilizado para implementar la navegación con rutas nombradas en Flutter. Estas rutas deben estar previamente definidas en el mapa de rutas de MaterialApp o CupertinoApp usando la propiedad 'routes'.",
    "category": "Navegación"
  },
  {
    "id": "110",
    "text": "¿Cuál es la mejor manera de manejar excepciones asíncronas en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Usar try/catch dentro de bloques async/await"
      },
      {
        "id": "B",
        "text": "Usar el método onError() en cada Future"
      },
      {
        "id": "C",
        "text": "Usar GlobalExceptionHandler.register()"
      },
      {
        "id": "D",
        "text": "Las excepciones asíncronas no necesitan manejo especial"
      }
    ],
    "correctOptionId": "A",
    "explanation": "La mejor manera de manejar excepciones asíncronas en Flutter es usando bloques try/catch dentro de funciones async/await. Esto permite capturar y manejar las excepciones de manera similar al código síncrono, lo que hace que el código sea más legible y mantenible. También puedes usar catchError() en Futures para el mismo propósito.",
    "category": "Asincronía"
  },
  {
    "id": "112",
    "text": "¿Cuál es la diferencia entre el método initState() y el constructor de un StatefulWidget?",
    "options": [
      {
        "id": "A",
        "text": "No hay diferencia, son intercambiables"
      },
      {
        "id": "B",
        "text": "initState() se llama cuando el widget se inserta en el árbol, el constructor cuando se crea la instancia"
      },
      {
        "id": "C",
        "text": "El constructor inicializa propiedades finales, initState() inicializa estado mutable"
      },
      {
        "id": "D",
        "text": "initState() se llama cada vez que el widget se reconstruye, el constructor solo la primera vez"
      }
    ],
    "correctOptionId": "B",
    "explanation": "La principal diferencia es que el constructor de la clase State se llama cuando se crea la instancia del estado, mientras que initState() se llama cuando el widget se inserta en el árbol. En initState() ya tienes acceso al contexto y widget heredados, cosa que no ocurre en el constructor. Además, initState() es el lugar adecuado para inicializar suscripciones o controladores.",
    "category": "Fundamentos"
  },
  {
    "id": "113",
    "text": "¿Qué es un Stream en Flutter y cómo se diferencia de un Future?",
    "options": [
      {
        "id": "A",
        "text": "Stream es síncrono y Future es asíncrono"
      },
      {
        "id": "B",
        "text": "Stream emite múltiples valores a lo largo del tiempo, Future emite un solo valor"
      },
      {
        "id": "C",
        "text": "Stream es para operaciones de red, Future para operaciones locales"
      },
      {
        "id": "D",
        "text": "Stream es obsoleto, Flutter recomienda usar solo Future"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Un Stream en Flutter es una secuencia de eventos asíncronos que puede emitir múltiples valores a lo largo del tiempo, mientras que un Future representa un único valor asíncrono. Los Streams son ideales para datos que cambian con el tiempo (como actualizaciones de ubicación, eventos de UI o datos en tiempo real), mientras que los Futures son mejores para operaciones que se completan una sola vez.",
    "category": "Asincronía"
  },
  {
    "id": "115",
    "text": "¿Qué son las keys GlobalKey en Flutter y cuándo deberían utilizarse?",
    "options": [
      {
        "id": "A",
        "text": "Claves para acceder a recursos globales como imágenes o fuentes"
      },
      {
        "id": "B",
        "text": "Claves únicas globalmente que permiten acceder a información de un widget desde cualquier parte de la aplicación"
      },
      {
        "id": "C",
        "text": "Claves para definir variables globales en toda la aplicación"
      },
      {
        "id": "D",
        "text": "Claves generadas automáticamente por Flutter para todos los widgets"
      }
    ],
    "correctOptionId": "B",
    "explanation": "GlobalKey es un tipo de clave en Flutter que es única globalmente y permite acceder a información sobre un widget específico desde cualquier parte de la aplicación. Se deben utilizar con moderación debido a su costo de rendimiento, y son apropiadas cuando necesitas acceder al estado de un widget desde otro widget que no está directamente conectado en el árbol, o cuando necesitas manipular un widget específico (como Form, Navigator) desde código externo.",
    "category": "Fundamentos"
  },
  {
    "id": "119",
    "text": "¿Qué es un BuildContext en Flutter y por qué es importante?",
    "options": [
      {
        "id": "A",
        "text": "Un objeto que contiene información sobre la ubicación de un widget en el árbol"
      },
      {
        "id": "B",
        "text": "Una herramienta para construir widgets personalizados"
      },
      {
        "id": "C",
        "text": "Un objeto que almacena el historial de cambios en un widget"
      },
      {
        "id": "D",
        "text": "Una interfaz para acceder a los recursos del sistema"
      }
    ],
    "correctOptionId": "A",
    "explanation": "BuildContext es un objeto que contiene información sobre la ubicación de un widget en el árbol. Es importante porque permite a los widgets interactuar con sus ancestros (como Theme.of(context) o MediaQuery.of(context)), proporciona acceso a servicios como la navegación (Navigator.of(context)), y es esencial para la ubicación correcta de elementos como diálogos o tooltips.",
    "category": "Fundamentos"
  },
  {
    "id": "121",
    "text": "¿Qué es DartPad?",
    "options": [
      {
        "id": "A",
        "text": "Un editor de texto especializado para Dart que debe instalarse localmente"
      },
      {
        "id": "B",
        "text": "Una herramienta en línea para escribir, ejecutar y compartir código Dart sin instalación"
      },
      {
        "id": "C",
        "text": "Un compilador de Dart a JavaScript"
      },
      {
        "id": "D",
        "text": "Un depurador para aplicaciones Flutter"
      }
    ],
    "correctOptionId": "B",
    "explanation": "DartPad es una herramienta en línea que permite escribir, ejecutar y compartir código Dart y Flutter sin necesidad de instalar nada en el equipo local. Es útil para aprender, experimentar y compartir ejemplos de código.",
    "category": "Configuración"
  },
  {
    "id": "123",
    "text": "¿Qué es Firebase Authentication en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget para crear formularios de inicio de sesión"
      },
      {
        "id": "B",
        "text": "Un servicio que permite la autenticación de usuarios mediante diferentes proveedores"
      },
      {
        "id": "C",
        "text": "Una biblioteca para encriptar credenciales de usuario"
      },
      {
        "id": "D",
        "text": "Un sistema para verificar la identidad del desarrollador"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Firebase Authentication es un servicio que facilita la creación de sistemas de autenticación seguros en aplicaciones Flutter, permitiendo autenticar usuarios mediante email/contraseña, proveedores de redes sociales, teléfono, y más.",
    "category": "Firebase"
  },
  {
    "id": "124",
    "text": "¿Cuál es la base de datos en tiempo real de Firebase?",
    "options": [
      {
        "id": "A",
        "text": "Firebase SQL"
      },
      {
        "id": "B",
        "text": "Firestore"
      },
      {
        "id": "C",
        "text": "Realtime Database"
      },
      {
        "id": "D",
        "text": "Firebase MongoDB"
      }
    ],
    "correctOptionId": "C",
    "explanation": "Realtime Database es la base de datos NoSQL en tiempo real original de Firebase. Almacena datos en formato JSON y permite sincronización en tiempo real entre todos los clientes conectados.",
    "category": "Firebase"
  },
  {
    "id": "125",
    "text": "¿Qué paquete se utiliza para implementar Google Maps en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "flutter_maps"
      },
      {
        "id": "B",
        "text": "google_maps_flutter"
      },
      {
        "id": "C",
        "text": "maps_api"
      },
      {
        "id": "D",
        "text": "flutter_google_maps"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El paquete google_maps_flutter es el plugin oficial para implementar mapas de Google en aplicaciones Flutter, permitiendo mostrar mapas, marcadores, polígonos y más.",
    "category": "Ubicación"
  },
  {
    "id": "126",
    "text": "¿Qué permiso es necesario para acceder a la ubicación del dispositivo en Android?",
    "options": [
      {
        "id": "A",
        "text": "android.permission.GPS"
      },
      {
        "id": "B",
        "text": "android.permission.ACCESS_FINE_LOCATION"
      },
      {
        "id": "C",
        "text": "android.permission.LOCATION"
      },
      {
        "id": "D",
        "text": "android.permission.GET_LOCATION"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El permiso android.permission.ACCESS_FINE_LOCATION es necesario para acceder a la ubicación precisa del dispositivo en Android. Debe declararse en el archivo AndroidManifest.xml y solicitarse al usuario en tiempo de ejecución.",
    "category": "Ubicación"
  },
  {
    "id": "127",
    "text": "¿Qué widget se utiliza para mostrar contenido web en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "WebView"
      },
      {
        "id": "B",
        "text": "BrowserWidget"
      },
      {
        "id": "C",
        "text": "HtmlView"
      },
      {
        "id": "D",
        "text": "WebBrowser"
      }
    ],
    "correctOptionId": "A",
    "explanation": "WebView es el widget que permite mostrar contenido web dentro de una aplicación Flutter. Requiere el uso del paquete webview_flutter para su implementación.",
    "category": "Widgets"
  },
  {
    "id": "128",
    "text": "¿Cómo se muestra un diálogo de alerta en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Dialog.show(context)"
      },
      {
        "id": "B",
        "text": "showDialog(context: context, builder: (context) => AlertDialog(...))"
      },
      {
        "id": "C",
        "text": "Alert.display(context)"
      },
      {
        "id": "D",
        "text": "context.showAlert()"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Para mostrar un diálogo de alerta en Flutter, se utiliza la función showDialog con un BuildContext y un builder que retorna un widget AlertDialog con el contenido del diálogo.",
    "category": "Widgets"
  },
  {
    "id": "129",
    "text": "¿Qué archivo se utiliza para configurar las propiedades de una aplicación Android en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "android/app/build.gradle"
      },
      {
        "id": "B",
        "text": "android/settings.gradle"
      },
      {
        "id": "C",
        "text": "android/gradle.properties"
      },
      {
        "id": "D",
        "text": "android/local.properties"
      }
    ],
    "correctOptionId": "A",
    "explanation": "El archivo android/app/build.gradle se utiliza para configurar propiedades específicas de la aplicación Android en un proyecto Flutter, como la versión del SDK, dependencias, nombre del paquete, y más.",
    "category": "Configuración"
  },
  {
    "id": "130",
    "text": "¿Qué se necesita para publicar una aplicación Flutter en Google Play Store?",
    "options": [
      {
        "id": "A",
        "text": "Sólo un archivo APK firmado"
      },
      {
        "id": "B",
        "text": "Un bundle de la aplicación (AAB) firmado y una cuenta de desarrollador Google Play"
      },
      {
        "id": "C",
        "text": "El código fuente de la aplicación en GitHub"
      },
      {
        "id": "D",
        "text": "Un certificado SSL"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Para publicar una aplicación Flutter en Google Play Store se necesita un Android App Bundle (AAB) firmado con una clave de firma y una cuenta de desarrollador de Google Play activa (con pago único). También se requiere material promocional, políticas de privacidad, etc.",
    "category": "Publicación"
  },
  {
    "id": "131",
    "text": "¿Cuál es el IDE recomendado oficialmente para desarrollar con Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Sublime Text"
      },
      {
        "id": "B",
        "text": "Visual Studio Code o Android Studio"
      },
      {
        "id": "C",
        "text": "Notepad++"
      },
      {
        "id": "D",
        "text": "XCode"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Visual Studio Code y Android Studio son los dos IDEs oficialmente recomendados y mejor soportados para el desarrollo con Flutter. Ambos disponen de plugins específicos que ofrecen funcionalidades como hot reload, depuración, completado de código y otras herramientas específicas para Flutter.",
    "category": "Configuración"
  },
  {
    "id": "132",
    "text": "¿Cómo se instala el plugin de Flutter en Android Studio?",
    "options": [
      {
        "id": "A",
        "text": "Se descarga manualmente del sitio web de Flutter"
      },
      {
        "id": "B",
        "text": "Desde File > Settings > Plugins, buscando 'Flutter' e instalándolo"
      },
      {
        "id": "C",
        "text": "Flutter viene preinstalado en Android Studio"
      },
      {
        "id": "D",
        "text": "Usando el comando 'flutter install-ide-plugin'"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Para instalar el plugin de Flutter en Android Studio, hay que ir a File > Settings > Plugins (o Android Studio > Preferences > Plugins en macOS), buscar 'Flutter' en el marketplace e instalarlo. El plugin de Dart se instalará automáticamente como dependencia.",
    "category": "Configuración"
  },
  {
    "id": "133",
    "text": "¿Cómo se implementa un switch case en Dart?",
    "options": [
      {
        "id": "A",
        "text": "switch (valor) { case valor1: // código; break; default: // código; }"
      },
      {
        "id": "B",
        "text": "switch (valor) { when valor1: // código; otherwise: // código; }"
      },
      {
        "id": "C",
        "text": "switch { case valor == valor1: // código; default: // código; }"
      },
      {
        "id": "D",
        "text": "switch (valor) { match valor1: // código; else: // código; }"
      }
    ],
    "correctOptionId": "A",
    "explanation": "En Dart, la sintaxis correcta para un switch case es: switch (expresión) { case valor1: // código; break; default: // código; }. El break es necesario para evitar la ejecución en cascada, excepto en casos específicos donde se desee este comportamiento.",
    "category": "Dart"
  },
  {
    "id": "134",
    "text": "¿Qué es el bucle for...in en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Una estructura que itera sobre los índices de una colección"
      },
      {
        "id": "B",
        "text": "Una estructura que itera sobre los elementos de una colección"
      },
      {
        "id": "C",
        "text": "Una estructura que ejecuta un bloque de código mientras una condición sea verdadera"
      },
      {
        "id": "D",
        "text": "Una estructura que ejecuta un código específico un número fijo de veces"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El bucle for...in en Dart (escrito como 'for (var elemento in colección)') itera sobre cada elemento de una colección como listas o conjuntos, proporcionando directamente el elemento en cada iteración en lugar de su índice.",
    "category": "Dart"
  },
  {
    "id": "135",
    "text": "¿Cómo se configura un emulador de Android para pruebas de Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Desde la línea de comandos con 'flutter emulator'"
      },
      {
        "id": "B",
        "text": "Desde Android Studio, en AVD Manager"
      },
      {
        "id": "C",
        "text": "Descargando una aplicación de emulador de la Play Store"
      },
      {
        "id": "D",
        "text": "Utilizando BlueStacks u otros emuladores de terceros"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Se configura un emulador de Android para Flutter principalmente a través del AVD (Android Virtual Device) Manager en Android Studio. Desde allí, se pueden crear y gestionar dispositivos virtuales con diferentes configuraciones de hardware y versiones de Android.",
    "category": "Configuración"
  },
  {
    "id": "136",
    "text": "¿Qué se necesita para ejecutar una aplicación Flutter en un dispositivo iOS real?",
    "options": [
      {
        "id": "A",
        "text": "Solo un Mac con XCode instalado"
      },
      {
        "id": "B",
        "text": "Un Mac con XCode, una cuenta de desarrollador de Apple y un dispositivo iOS"
      },
      {
        "id": "C",
        "text": "Cualquier ordenador con iTunes instalado"
      },
      {
        "id": "D",
        "text": "Un iPhone jailbreak"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Para ejecutar una aplicación Flutter en un dispositivo iOS real, se necesita un Mac con XCode instalado, una cuenta de desarrollador de Apple (gratis o de pago), y un dispositivo iOS conectado por USB con el modo de desarrollador activado.",
    "category": "Configuración"
  },
  {
    "id": "137",
    "text": "¿Cómo se implementa la navegación con rutas nombradas en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Navigator.of(context).pushNamed('/ruta')"
      },
      {
        "id": "B",
        "text": "Navigation.goTo('/ruta')"
      },
      {
        "id": "C",
        "text": "Routes.navigate('/ruta')"
      },
      {
        "id": "D",
        "text": "context.navigateTo('/ruta')"
      }
    ],
    "correctOptionId": "A",
    "explanation": "La navegación con rutas nombradas en Flutter se implementa primero definiendo las rutas en el MaterialApp (initialRoute y routes), y luego usando Navigator.of(context).pushNamed('/ruta') para navegar a una ruta específica por su nombre.",
    "category": "Navegación"
  },
  {
    "id": "138",
    "text": "¿Qué widget se utiliza para aprovechar el gesto de deslizar hacia atrás en iOS?",
    "options": [
      {
        "id": "A",
        "text": "IOSNavigator"
      },
      {
        "id": "B",
        "text": "CupertinoPageScaffold"
      },
      {
        "id": "C",
        "text": "SwipeBackGesture"
      },
      {
        "id": "D",
        "text": "BackButton"
      }
    ],
    "correctOptionId": "B",
    "explanation": "CupertinoPageScaffold es parte de la biblioteca Cupertino de Flutter que implementa el diseño y comportamiento de iOS, incluyendo el gesto de deslizar hacia atrás para navegación. Se puede usar en combinación con CupertinoNavigator para una experiencia de navegación al estilo iOS.",
    "category": "Navegación"
  },
  {
    "id": "139",
    "text": "¿Qué es un TabBar en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget que muestra pestañas horizontales para navegación"
      },
      {
        "id": "B",
        "text": "Un widget que muestra una barra de progreso"
      },
      {
        "id": "C",
        "text": "Un widget para crear espacios tabulados"
      },
      {
        "id": "D",
        "text": "Un widget para alinear elementos en forma de tabla"
      }
    ],
    "correctOptionId": "A",
    "explanation": "TabBar es un widget de Material Design que muestra pestañas horizontales para navegación entre vistas. Se utiliza generalmente junto con TabBarView para crear una interfaz con pestañas donde el contenido cambia al seleccionar diferentes pestañas.",
    "category": "Widgets"
  },
  {
    "id": "140",
    "text": "¿Qué se necesita para publicar una aplicación Flutter en la App Store de Apple?",
    "options": [
      {
        "id": "A",
        "text": "Solo un archivo IPA compilado"
      },
      {
        "id": "B",
        "text": "Una cuenta de desarrollador de Apple pagada, certificados, y un archivo IPA firmado"
      },
      {
        "id": "C",
        "text": "Publicar primero en Google Play Store"
      },
      {
        "id": "D",
        "text": "Solo enviar el código fuente a Apple"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Para publicar una aplicación Flutter en la App Store, se necesita una cuenta de desarrollador de Apple pagada ($99/año), certificados de distribución, un archivo IPA firmado y subido a través de Xcode o App Store Connect, y pasar la revisión de la App Store, que verifica que la aplicación cumple con todas las directrices.",
    "category": "Publicación"
  },
  {
    "id": "141",
    "text": "¿Qué es el widget Drawer en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un widget para dibujar gráficos personalizados"
      },
      {
        "id": "B",
        "text": "Un panel lateral deslizable que normalmente contiene enlaces de navegación"
      },
      {
        "id": "C",
        "text": "Un widget para crear efectos de sombra"
      },
      {
        "id": "D",
        "text": "Un contenedor que puede redimensionarse"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El widget Drawer en Flutter es un panel lateral deslizable que suele contener opciones de menú y navegación. Se utiliza comúnmente con Scaffold.drawer y se puede abrir deslizando desde el borde de la pantalla o mediante un botón en la AppBar.",
    "category": "Widgets"
  },
  {
    "id": "142",
    "text": "¿Cómo se añaden iconos específicos para iOS y Android en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Usando el widget Icon con diferentes parámetros según la plataforma"
      },
      {
        "id": "B",
        "text": "Importando paquetes separados para cada plataforma"
      },
      {
        "id": "C",
        "text": "Usando CupertinoIcons para iOS y MaterialIcons para Android"
      },
      {
        "id": "D",
        "text": "No es posible, Flutter usa los mismos iconos en todas las plataformas"
      }
    ],
    "correctOptionId": "C",
    "explanation": "Flutter proporciona iconos específicos para cada plataforma a través de diferentes paquetes: CupertinoIcons para un aspecto iOS y MaterialIcons para Android/Material Design. Se pueden usar condicionalmente con un widget como Platform.isIOS para adaptar la interfaz a cada plataforma.",
    "category": "Widgets"
  },
  {
    "id": "143",
    "text": "¿Qué es un widget ListView.builder?",
    "options": [
      {
        "id": "A",
        "text": "Un widget que construye listas de otros widgets"
      },
      {
        "id": "B",
        "text": "Un widget que crea listas perezosas (lazy) generando elementos solo cuando son visibles"
      },
      {
        "id": "C",
        "text": "Un constructor para crear ListTile personalizados"
      },
      {
        "id": "D",
        "text": "Un widget que construye todas las vistas de lista de una aplicación"
      }
    ],
    "correctOptionId": "B",
    "explanation": "ListView.builder es un constructor de ListView que genera elementos de forma perezosa (lazy), creando solo los widgets que son visibles en la pantalla. Es eficiente para listas largas o infinitas ya que no construye todos los elementos a la vez.",
    "category": "Widgets"
  },
  {
    "id": "144",
    "text": "¿Qué es un widget DataTable?",
    "options": [
      {
        "id": "A",
        "text": "Un widget para mostrar datos en formato de tabla con filas y columnas"
      },
      {
        "id": "B",
        "text": "Un widget para almacenar datos localmente"
      },
      {
        "id": "C",
        "text": "Un widget para conectarse a bases de datos externas"
      },
      {
        "id": "D",
        "text": "Un widget para convertir datos entre diferentes formatos"
      }
    ],
    "correctOptionId": "A",
    "explanation": "DataTable es un widget de Material Design que muestra información en formato de tabla con filas y columnas. Incluye funcionalidades como encabezados, ordenación y selección de filas, y es útil para presentar conjuntos de datos estructurados.",
    "category": "Widgets"
  },
  {
    "id": "145",
    "text": "¿Qué es el widget BottomNavigationBar?",
    "options": [
      {
        "id": "A",
        "text": "Una barra de navegación que aparece en la parte inferior de la aplicación"
      },
      {
        "id": "B",
        "text": "Un widget para crear barras de progreso en la parte inferior"
      },
      {
        "id": "C",
        "text": "Un widget para añadir publicidad en la parte inferior"
      },
      {
        "id": "D",
        "text": "Un widget para mostrar notificaciones en la parte inferior"
      }
    ],
    "correctOptionId": "A",
    "explanation": "BottomNavigationBar es un widget de Material Design que muestra una barra de navegación en la parte inferior de la pantalla con iconos y etiquetas opcionales. Se utiliza para la navegación entre las principales secciones de una aplicación (normalmente entre 3 y 5 destinos).",
    "category": "Widgets"
  },
  {
    "id": "146",
    "text": "¿Qué widget se utiliza para crear listas con elementos que pueden expandirse y contraerse?",
    "options": [
      {
        "id": "A",
        "text": "ListView"
      },
      {
        "id": "B",
        "text": "ExpansionTile"
      },
      {
        "id": "C",
        "text": "ExpandableList"
      },
      {
        "id": "D",
        "text": "CollapsiblePanel"
      }
    ],
    "correctOptionId": "B",
    "explanation": "ExpansionTile es un widget que permite crear elementos de lista que pueden expandirse y contraerse con un toque. Consiste en un encabezado (título e icono) y un área de contenido expandible que se muestra u oculta según su estado.",
    "category": "Widgets"
  },
  {
    "id": "147",
    "text": "¿Cómo se personaliza una fuente en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Usando el widget Font con la propiedad family"
      },
      {
        "id": "B",
        "text": "Configurando la propiedad fontFamily en ThemeData y declarando la fuente en pubspec.yaml"
      },
      {
        "id": "C",
        "text": "Instalando la fuente a nivel del sistema operativo"
      },
      {
        "id": "D",
        "text": "Creando un servicio FontService personalizado"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Para personalizar una fuente en Flutter: 1) Añade los archivos de fuente a una carpeta del proyecto, 2) Declara las fuentes en la sección fonts del pubspec.yaml, 3) Usa la fuente estableciendo fontFamily en ThemeData o directamente en el estilo de los widgets Text.",
    "category": "Configuración"
  },
  {
    "id": "148",
    "text": "¿Qué widget se utiliza para crear un campo de texto con validación en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Input"
      },
      {
        "id": "B",
        "text": "TextInput"
      },
      {
        "id": "C",
        "text": "TextField"
      },
      {
        "id": "D",
        "text": "TextFormField"
      }
    ],
    "correctOptionId": "D",
    "explanation": "TextFormField es un widget que extiende TextField añadiendo integración con el widget Form padre. Permite realizar validación de entrada, mostrar mensajes de error, y gestionar el estado del formulario, haciendo más sencilla la creación de formularios con validación.",
    "category": "Widgets"
  },
  {
    "id": "149",
    "text": "¿Qué es un SelectableText en Flutter?",
    "options": [
      {
        "id": "A",
        "text": "Un texto que puede ser seleccionado y copiado por el usuario"
      },
      {
        "id": "B",
        "text": "Un texto que cambia de color cuando es seleccionado"
      },
      {
        "id": "C",
        "text": "Un texto que se puede seleccionar de una lista desplegable"
      },
      {
        "id": "D",
        "text": "Un texto que se puede arrastrar a diferentes posiciones"
      }
    ],
    "correctOptionId": "A",
    "explanation": "SelectableText es un widget que muestra texto que el usuario puede seleccionar y copiar, a diferencia del widget Text estándar que no permite selección. Es útil para mostrar información que los usuarios podrían querer copiar, como códigos o direcciones.",
    "category": "Widgets"
  },
  {
    "id": "150",
    "text": "¿Qué widget se utiliza para apilar widgets uno encima de otro?",
    "options": [
      {
        "id": "A",
        "text": "Overlay"
      },
      {
        "id": "B",
        "text": "Stack"
      },
      {
        "id": "C",
        "text": "Layer"
      },
      {
        "id": "D",
        "text": "ZIndex"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Stack es un widget que permite apilar varios hijos uno encima de otro. Junto con el widget Positioned, permite posicionar los widgets hijos de forma relativa a los bordes del Stack, lo que es útil para crear interfaces complejas con elementos superpuestos.",
    "category": "Widgets"
  },
  {
    "id": "167",
    "text": "¿Qué es el widget Card y qué características ofrece?",
    "options": [
      {
        "id": "A",
        "text": "Un widget de navegación para moverse entre pantallas"
      },
      {
        "id": "B",
        "text": "Un contenedor rectangular con elevación, bordes redondeados y sombra"
      },
      {
        "id": "C",
        "text": "Un widget para mostrar imágenes con forma de tarjeta"
      },
      {
        "id": "D",
        "text": "Un widget exclusivo para formularios"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Card es un widget de Material Design que proporciona un contenedor rectangular con elevación, bordes redondeados y sombra. Se utiliza comúnmente para presentar información relacionada de manera visualmente atractiva. Implementa las especificaciones de tarjetas de Material Design.",
    "category": "Widgets"
  },
  {
    "id": "168",
    "text": "¿Cuáles son las diferentes formas de cargar imágenes en Flutter usando el widget Image?",
    "options": [
      {
        "id": "A",
        "text": "Sólo desde activos locales con Image.asset()"
      },
      {
        "id": "B",
        "text": "Sólo desde la red con Image.network()"
      },
      {
        "id": "C",
        "text": "Image.asset(), Image.network(), Image.file() e Image.memory()"
      },
      {
        "id": "D",
        "text": "Solamente desde URLs web"
      }
    ],
    "correctOptionId": "C",
    "explanation": "Flutter ofrece varias formas de cargar imágenes mediante el widget Image: Image.asset() para cargar imágenes desde los activos del proyecto (pubspec.yaml), Image.network() para cargar desde URLs, Image.file() para cargar desde el sistema de archivos del dispositivo, e Image.memory() para cargar desde un array de bytes en memoria.",
    "category": "Widgets"
  },
  {
    "id": "169",
    "text": "¿Cuáles son los tipos de comentarios disponibles en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Solo comentarios de una línea con //"
      },
      {
        "id": "B",
        "text": "Solo comentarios de múltiples líneas con /* */"
      },
      {
        "id": "C",
        "text": "Comentarios de una línea, múltiples líneas y documentación"
      },
      {
        "id": "D",
        "text": "Dart no soporta comentarios en el código"
      }
    ],
    "correctOptionId": "C",
    "explanation": "Dart soporta tres tipos de comentarios: comentarios de una línea con // (doble barra), comentarios de múltiples líneas con /* */ (barra-asterisco), y comentarios de documentación con /// (triple barra) o /** */ que son utilizados para generar documentación automática.",
    "category": "Dart"
  },
  {
    "id": "171",
    "text": "¿Cómo se estructura una declaración if-else en Dart?",
    "options": [
      {
        "id": "A",
        "text": "if (condición) { código } else if (condición) { código } else { código }"
      },
      {
        "id": "B",
        "text": "if condición then código else if condición then código else código"
      },
      {
        "id": "C",
        "text": "if [condición] => { código } else if [condición] => { código } else => { código }"
      },
      {
        "id": "D",
        "text": "if: condición do: código else-if: condición do: código else: código"
      }
    ],
    "correctOptionId": "A",
    "explanation": "En Dart, la estructura if-else se escribe como: if (condición) { código } else if (condición) { código } else { código }. Las llaves son opcionales si solo hay una instrucción dentro del bloque. La condición debe estar entre paréntesis y devolver un valor booleano.",
    "category": "Dart"
  },
  {
    "id": "172",
    "text": "¿Cuáles son los operadores lógicos en Dart?",
    "options": [
      {
        "id": "A",
        "text": "AND (&&), OR (||) y NOT (!)"
      },
      {
        "id": "B",
        "text": "AND (&), OR (|) y NOT (~)"
      },
      {
        "id": "C",
        "text": "AND (AND), OR (OR) y NOT (NOT)"
      },
      {
        "id": "D",
        "text": "AND (and), OR (or) y NOT (not)"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Dart utiliza los operadores lógicos: && (AND lógico) que devuelve true si ambas condiciones son verdaderas, || (OR lógico) que devuelve true si al menos una de las condiciones es verdadera, y ! (NOT lógico) que invierte el valor de la condición. Es importante destacar que & y | son operadores a nivel de bits, no operadores lógicos.",
    "category": "Dart"
  },
  {
    "id": "173",
    "text": "¿Cuáles son los tipos de bucles while disponibles en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Solo while"
      },
      {
        "id": "B",
        "text": "while y do-while"
      },
      {
        "id": "C",
        "text": "while, do-while y until"
      },
      {
        "id": "D",
        "text": "while, do-while y while-do"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Dart proporciona dos tipos de bucles while: (1) while (condición) { código }, que evalúa la condición antes de ejecutar el bloque de código y puede no ejecutarse si la condición es falsa inicialmente, y (2) do { código } while (condición), que ejecuta el bloque de código al menos una vez y luego evalúa la condición para decidir si continúa.",
    "category": "Dart"
  },
  {
    "id": "174",
    "text": "¿Cómo se estructura una declaración switch-case en Dart?",
    "options": [
      {
        "id": "A",
        "text": "switch (expresión) { case valor: código; break; default: código; }"
      },
      {
        "id": "B",
        "text": "switch (expresión) { case valor: código; case valor: código; }"
      },
      {
        "id": "C",
        "text": "switch expresión: case valor => código, case valor => código"
      },
      {
        "id": "D",
        "text": "switch: expresión { when: valor do: código, default: código }"
      }
    ],
    "correctOptionId": "A",
    "explanation": "En Dart, la estructura switch-case se escribe como: switch (expresión) { case valor: código; break; ... default: código; }. Cada caso debe terminar con break, continue, return o throw, o Dart producirá un error. La sección default es opcional y se ejecuta cuando ningún caso coincide con el valor de la expresión.",
    "category": "Dart"
  },
  {
    "id": "175",
    "text": "¿Cuál es la función de la declaración break en Dart?",
    "options": [
      {
        "id": "A",
        "text": "Finalizar el programa inmediatamente"
      },
      {
        "id": "B",
        "text": "Terminar la ejecución del bucle o switch actual y continuar con el código siguiente"
      },
      {
        "id": "C",
        "text": "Pausar temporalmente la ejecución del programa"
      },
      {
        "id": "D",
        "text": "Saltar a una etiqueta específica en el código"
      }
    ],
    "correctOptionId": "B",
    "explanation": "La declaración break en Dart se utiliza para terminar la ejecución del bucle (for, while, do-while) o la estructura switch actual, transfiriendo el control al código que sigue inmediatamente después de esa estructura. En bucles anidados, break solo termina el bucle más interno a menos que se use con una etiqueta.",
    "category": "Dart"
  },
  {
    "id": "176",
    "text": "El siguiente código se utiliza para añadir un botón de acción flotante a una interfaz de aplicación Flutter. ¿Cuál de las siguientes funciones o métodos se puede utilizar para añadir una acción a este botón si el usuario de la aplicación lo toca?",
    "codeSnippet": "floatingActionButton: FloatingActionButton(\nchild: Icon(Icons.phone),\n),",
    "options": [
      {
        "id": "A",
        "text": "GoTo"
      },
      {
        "id": "B",
        "text": "onPressed"
      },
      {
        "id": "C",
        "text": "JumupNow"
      },
      {
        "id": "D",
        "text": "flyTo"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El método onPressed es el utilizado en Flutter para manejar eventos de toque en botones, incluyendo FloatingActionButton. Este método recibe una función callback que se ejecutará cuando el usuario toque el botón.",
    "category": "Widgets"
  },
  {
    "id": "177",
    "text": "Añadir un widget Slider en una interfaz de aplicación Flutter debe usarse para seleccionar múltiples valores al mismo tiempo.",
    "options": [
      {
        "id": "A",
        "text": "Verdadero"
      },
      {
        "id": "B",
        "text": "Falso"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Falso. El widget Slider en Flutter está diseñado para seleccionar un único valor dentro de un rango continuo. Para seleccionar múltiples valores, se debería utilizar el widget RangeSlider que permite seleccionar un rango con valores mínimo y máximo, o implementar múltiples Sliders independientes.",
    "category": "Widgets"
  },
  {
    "id": "178",
    "text": "Este widget de Flutter se utiliza para alternar el estado on/off de una única configuración. ¿Cuál de las siguientes opciones representa esta definición?",
    "options": [
      {
        "id": "A",
        "text": "onOff Widget"
      },
      {
        "id": "B",
        "text": "SlideA Widget"
      },
      {
        "id": "C",
        "text": "noYes Widget"
      },
      {
        "id": "D",
        "text": "Switch Widget"
      }
    ],
    "correctOptionId": "D",
    "explanation": "El Switch Widget en Flutter se utiliza para alternar entre estados activado/desactivado (on/off) de una configuración única. Es un componente de interfaz de usuario común que permite a los usuarios cambiar una configuración booleana de manera visual mediante un deslizador que muestra claramente cuando está activado o desactivado.",
    "category": "Widgets"
  },
  {
    "id": "179",
    "text": "Un plug-in se utiliza para introducir la fecha en la interfaz de tu aplicación Flutter en lugar de pedir al usuario de la aplicación que la añada manualmente. ¿Cuál de las siguientes opciones representa esta definición?",
    "options": [
      {
        "id": "A",
        "text": "DateInsert() widget"
      },
      {
        "id": "B",
        "text": "Date Picker plug-in"
      },
      {
        "id": "C",
        "text": "Date Dialog plug-in"
      },
      {
        "id": "D",
        "text": "Date Mark plug-in"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El Date Picker plug-in (o showDatePicker en Flutter) es el componente utilizado para permitir a los usuarios seleccionar una fecha de forma visual e interactiva, en lugar de tener que introducirla manualmente. Este widget muestra un calendario intuitivo donde el usuario puede navegar entre meses y años para seleccionar una fecha específica.",
    "category": "Widgets"
  },
  {
    "id": "180",
    "text": "Para configurar un CheckboxGroup o un RadioButtonGroup en una aplicación Flutter, primero debes establecer las configuraciones que se ilustran en la imagen de esta pregunta:\ndependencies:\n  flutter:\n    sdk: flutter\n  grouped_buttons: ^1.0.4\n¿Cuál es el nombre del archivo que incluye estas configuraciones?",
    "options": [
      {
        "id": "A",
        "text": "README.md"
      },
      {
        "id": "B",
        "text": "AndroidManifest.xml"
      },
      {
        "id": "C",
        "text": "pubspec.yaml"
      },
      {
        "id": "D",
        "text": "gradlew.bat"
      }
    ],
    "correctOptionId": "C",
    "explanation": "El archivo pubspec.yaml es donde se declaran todas las dependencias de un proyecto Flutter. Es en este archivo donde se añaden los paquetes externos como 'grouped_buttons' que se utilizarán en la aplicación. Este archivo también contiene metadatos del proyecto, configuración de assets, fuentes y otras propiedades del proyecto.",
    "category": "Configuración"
  },
  {
    "id": "181",
    "text": "Después de crear una aplicación Flutter, necesitas configurar un icono para tu aplicación.\nLa pregunta es:\nSi configuras un icono de aplicación en tu código Android de esta aplicación Flutter, el icono de tu código iOS para la misma aplicación Flutter se añadirá automáticamente.",
    "options": [
      {
        "id": "A",
        "text": "Verdadero"
      },
      {
        "id": "B",
        "text": "Falso"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Falso. Flutter utiliza el enfoque de código nativo para cada plataforma, por lo que los iconos deben configurarse por separado para Android e iOS. El icono de Android se configura en android/app/src/main/res/, mientras que el icono de iOS se configura en ios/Runner/Assets.xcassets/AppIcon.appiconset/. Existen paquetes como flutter_launcher_icons que pueden facilitar este proceso, pero la configuración sigue siendo específica para cada plataforma.",
    "category": "Desarrollo"
  },
  {
    "id": "182",
    "text": "Selecciona la opción correcta para completar la siguiente frase: El widget SnackBar se utiliza si quieres que tu aplicación muestre un mensaje............... en la parte inferior de la interfaz de tu aplicación.",
    "options": [
      {
        "id": "A",
        "text": "Durante unos segundos"
      },
      {
        "id": "B",
        "text": "Para siempre"
      },
      {
        "id": "C",
        "text": "Hasta que el usuario de la aplicación pulse el botón de cierre de este mensaje"
      },
      {
        "id": "D",
        "text": "Hasta que el usuario de la aplicación pulse el botón OK del mensaje"
      }
    ],
    "correctOptionId": "A",
    "explanation": "El widget SnackBar en Flutter se utiliza para mostrar mensajes temporales que aparecen en la parte inferior de la pantalla durante unos segundos y luego desaparecen automáticamente. Aunque se puede personalizar la duración con el parámetro 'duration', el comportamiento predeterminado es que sean temporales y no requieran interacción del usuario para desaparecer.",
    "category": "Widgets"
  },
  {
    "id": "183",
    "text": "Un widget Stateful es un widget dinámico que puede cambiar la apariencia de su contenido en respuesta a eventos desencadenados por las interacciones del usuario o cuando recibe datos.",
    "options": [
      {
        "id": "A",
        "text": "Verdadero"
      },
      {
        "id": "B",
        "text": "Falso"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Verdadero. Un StatefulWidget en Flutter es un widget dinámico que puede reconstruirse y actualizar su apariencia en respuesta a eventos, como interacciones del usuario o cambios en los datos. Estos widgets mantienen un estado que puede cambiar durante su ciclo de vida, a diferencia de los StatelessWidget que son inmutables.",
    "category": "Widgets"
  },
  {
    "id": "184",
    "text": "¿Cuántos widgets hijos se pueden añadir al widget Container?",
    "options": [
      {
        "id": "A",
        "text": "Widgets hijos ilimitados"
      },
      {
        "id": "B",
        "text": "Solo un widget hijo"
      },
      {
        "id": "C",
        "text": "Dos widgets hijos"
      },
      {
        "id": "D",
        "text": "Tres widgets hijos"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El widget Container en Flutter solo puede tener un único widget hijo. Si necesitas añadir múltiples widgets dentro de un Container, debes usar un widget de layout como Column, Row o Stack como el hijo del Container, y luego añadir múltiples widgets como hijos de ese widget de layout.",
    "category": "Widgets"
  },
  {
    "id": "185",
    "text": "¿Qué propiedad deberías usar para añadir una etiqueta, un icono y un texto de sugerencia en línea al widget TextField?",
    "options": [
      {
        "id": "A",
        "text": "ListView"
      },
      {
        "id": "B",
        "text": "InputDecoration"
      },
      {
        "id": "C",
        "text": "SizeBox"
      },
      {
        "id": "D",
        "text": "shrinkWrap: true"
      }
    ],
    "correctOptionId": "B",
    "explanation": "En Flutter, se utiliza la propiedad 'decoration' del widget TextField con un objeto InputDecoration para añadir elementos como etiquetas (label), iconos (icon) y textos de sugerencia (hintText). Este objeto permite personalizar completamente la apariencia del campo de texto con varios elementos visuales y ayudas para el usuario.",
    "category": "Widgets"
  },
  {
    "id": "186",
    "text": "Puedes añadir o importar una nueva fuente a tu Flutter colocando el archivo de fuente en una carpeta de fuentes en tu proyecto Flutter sin necesidad de declarar este archivo de fuente o la carpeta de fuentes en pubspec.yaml. ¿Es esto correcto?",
    "options": [
      {
        "id": "A",
        "text": "Verdadero"
      },
      {
        "id": "B",
        "text": "Falso"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Falso. Para utilizar fuentes personalizadas en Flutter, no solo debes colocar los archivos de fuente en una carpeta del proyecto, sino que también es obligatorio declararlos en el archivo pubspec.yaml en la sección 'fonts'. Esto permite que Flutter reconozca y registre las fuentes para su uso en la aplicación.",
    "category": "Configuración"
  },
  {
    "id": "187",
    "text": "Si instalas el SDK de Flutter en tu ordenador y lo configuras como un plug-in para Android Studio u otro software IDE, Android Studio podrá crear aplicaciones Flutter.",
    "options": [
      {
        "id": "A",
        "text": "Verdadero"
      },
      {
        "id": "B",
        "text": "Falso"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Verdadero. Una vez que el SDK de Flutter está instalado en tu ordenador y configurado como un plugin para Android Studio (o cualquier otro IDE compatible), Android Studio puede crear y gestionar aplicaciones Flutter. Esto se hace instalando el plugin de Flutter y Dart desde el marketplace de plugins de Android Studio, lo que añade soporte para crear proyectos Flutter, ejecutarlos y depurarlos directamente desde el IDE.",
    "category": "Configuración"
  },
  {
    "id": "188",
    "text": "Este widget se utiliza para envolver un Column, Row, Container u otros widgets. Este widget añade un tamaño de relleno alrededor del widget hijo. ¿A cuál de los siguientes términos corresponde esta definición?",
    "options": [
      {
        "id": "A",
        "text": "Image"
      },
      {
        "id": "B",
        "text": "SnackBar"
      },
      {
        "id": "C",
        "text": "Padding"
      },
      {
        "id": "D",
        "text": "AlertDialog"
      }
    ],
    "correctOptionId": "C",
    "explanation": "El widget Padding en Flutter se utiliza para añadir espacio (relleno) alrededor de su widget hijo. Es muy útil para crear márgenes internos y espaciado entre elementos de la interfaz. El Padding acepta un parámetro 'padding' que puede ser configurado con EdgeInsets para especificar cuánto espacio añadir en cada lado del widget hijo.",
    "category": "Widgets"
  },
  {
    "id": "189",
    "text": "Si quieres crear una aplicación Flutter usando un ordenador Mac, necesitas instalar Android Studio u otro software IDE y otro software prerrequisito Flutter SDK. Sin embargo, solo puedes probar tus aplicaciones Flutter usando un emulador de iPhone.",
    "options": [
      {
        "id": "A",
        "text": "Verdadero"
      },
      {
        "id": "B",
        "text": "Falso"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Falso. Aunque es cierto que necesitas instalar el SDK de Flutter y un IDE como Android Studio para desarrollar aplicaciones Flutter en Mac, puedes probar tus aplicaciones tanto en emuladores de iPhone (usando Xcode) como en emuladores de Android (usando Android Studio). Un Mac permite desarrollar y probar aplicaciones para ambas plataformas.",
    "category": "Configuración"
  },
  {
    "id": "190",
    "text": "Este widget te ayuda a tener un ancho y/o alto específico entre widgets. ¿A cuál de los siguientes términos corresponde esta definición?",
    "options": [
      {
        "id": "A",
        "text": "AppBar"
      },
      {
        "id": "B",
        "text": "SizedBox"
      },
      {
        "id": "C",
        "text": "SafeArea"
      },
      {
        "id": "D",
        "text": "onChanged"
      }
    ],
    "correctOptionId": "B",
    "explanation": "El widget SizedBox en Flutter se utiliza para crear un espacio con dimensiones específicas entre widgets. Permite establecer un ancho y/o alto fijo, lo que es útil para crear espaciado consistente en la interfaz de usuario. También puede usarse vacío (sin hijo) como un simple espaciador con dimensiones definidas.",
    "category": "Widgets"
  },
  {
    "id": "191",
    "text": "Cuando construyes una aplicación Flutter, puedes usar un emulador de Android o iPhone para probar la interfaz de usuario (UI) de tu aplicación y su flujo de trabajo. Pero NO puedes probar esta aplicación en un dispositivo Android o iPhone real antes de publicar tu aplicación en la tienda de Apple o Google.",
    "options": [
      {
        "id": "A",
        "text": "Verdadero"
      },
      {
        "id": "B",
        "text": "Falso"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Falso. Flutter permite probar aplicaciones en dispositivos físicos reales antes de publicarlas en las tiendas. Para Android, puedes habilitar el modo desarrollador en el dispositivo y conectarlo por USB. Para iOS, necesitas una cuenta de desarrollador de Apple y configurar el dispositivo en Xcode. Esta práctica es altamente recomendada para verificar el rendimiento y la experiencia de usuario en hardware real.",
    "category": "Configuración"
  },
  {
    "id": "192",
    "text": "En el desarrollo con Flutter, puedes añadir tres filas (Row) dentro de una columna (Column) y añadir una imagen dentro de cada fila.",
    "options": [
      {
        "id": "A",
        "text": "Verdadero"
      },
      {
        "id": "B",
        "text": "Falso"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Verdadero. En Flutter puedes anidar widgets de layout como Row dentro de Column. Es una práctica común crear una Column que contenga múltiples Row como hijos, y dentro de cada Row puedes añadir widgets Image u otros componentes. Esta flexibilidad en la composición de widgets es una de las fortalezas del sistema de diseño de Flutter.",
    "category": "Widgets"
  },
  {
    "id": "193",
    "text": "Flutter funciona con muchas herramientas de desarrollo que son compatibles con los plug-ins de Flutter (Flutter SDK). ¿Cuál de los siguientes softwares puede usarse para construir una aplicación Flutter? (Selecciona tres)",
    "options": [
      {
        "id": "A",
        "text": "NotePad"
      },
      {
        "id": "B",
        "text": "Visual Studio"
      },
      {
        "id": "C",
        "text": "IntelliJ"
      },
      {
        "id": "D",
        "text": "Android Studio"
      }
    ],
    "correctOptionId": "B,C,D",
    "explanation": "Las tres herramientas de desarrollo principales que son plenamente compatibles con Flutter son Visual Studio Code (B), IntelliJ IDEA (C) y Android Studio (D). Todas ellas ofrecen plugins oficiales para Flutter que proporcionan funciones como resaltado de sintaxis, depuración, y herramientas específicas para desarrollo Flutter. Aunque se podría usar un editor simple como NotePad, este no ofrece las herramientas y funcionalidades necesarias para un desarrollo eficiente con Flutter.",
    "category": "Configuración"
  },
  {
    "id": "194",
    "text": "................. comando comprueba tu entorno y muestra un informe del estado de tu instalación de Flutter y Android Studio u otro software IDE. ¿Cuál de las siguientes opciones es la respuesta correcta para completar el espacio en blanco anterior?",
    "options": [
      {
        "id": "A",
        "text": "Flutter Doctor"
      },
      {
        "id": "B",
        "text": "Flutter Connection"
      },
      {
        "id": "C",
        "text": "Flutter Screen"
      },
      {
        "id": "D",
        "text": "Flutter IDE_XML"
      }
    ],
    "correctOptionId": "A",
    "explanation": "Flutter Doctor es el comando que verifica el estado del entorno de desarrollo de Flutter. Al ejecutar 'flutter doctor' en la terminal, se analiza la instalación de Flutter, los IDEs configurados (como Android Studio), los dispositivos conectados y otras dependencias necesarias, mostrando un informe detallado de lo que está correctamente configurado y lo que necesita atención.",
    "category": "Configuración"
  },
  {
    "id": "195",
    "text": "¿Cuál de las siguientes opciones es la mejor respuesta para añadir una imagen desde el disco duro de tu ordenador a un proyecto Flutter?",
    "options": [
      {
        "id": "A",
        "text": "No puedes añadir una imagen desde el disco duro de tu ordenador a un proyecto Flutter. Solo puedes configurar tu código para usar una imagen desde un enlace web."
      },
      {
        "id": "B",
        "text": "Añadir una nueva carpeta (directorio) a la estructura de archivos de Flutter, copiar la imagen desde tu disco duro, pegar esta imagen en la carpeta de imágenes y luego configurar tu archivo Dart en este proyecto Flutter para usar este nombre de archivo de imagen."
      },
      {
        "id": "C",
        "text": "Añadir una nueva carpeta (directorio) a la estructura de archivos de Flutter, copiar la imagen desde tu disco duro, pegar esta imagen en la carpeta de imágenes, configurar tu archivo Dart en este proyecto Flutter para usar este nombre de archivo de imagen, configurar tu archivo pubspec.yaml del proyecto Flutter para usar esta carpeta de imágenes, y luego hacer clic en \"Packages get\" en la parte superior del archivo pubspec.yaml."
      },
      {
        "id": "D",
        "text": "Hacer clic en el menú Archivo en cualquier IDE de Flutter, seleccionar Insertar, seleccionar Imagen, navegar para seleccionar la imagen, hacer clic en Guardar tres veces y luego reiniciar tu IDE."
      }
    ],
    "correctOptionId": "C",
    "explanation": "Para añadir correctamente una imagen a un proyecto Flutter, debes: 1) Crear una carpeta de recursos (generalmente 'assets' o 'images'), 2) Colocar la imagen en esa carpeta, 3) Declarar la carpeta en el archivo pubspec.yaml bajo la sección 'assets', 4) Ejecutar 'flutter pub get' para actualizar las dependencias, y 5) Usar la imagen en tu código Dart mediante Image.asset('ruta/a/imagen.png'). Este proceso completo asegura que Flutter reconozca y pueda acceder a la imagen durante la compilación.",
    "category": "Configuración"
  },
  {
    "id": "196",
    "text": "Completa el espacio en blanco con la respuesta correcta que completa la siguiente frase. Si tienes algún error en tu código Dart de tu aplicación Flutter, la.......................... en la barra de estado de tu Android Studio muestra la descripción del error y también muestra la línea del código en la que está el error. Además, en la mayoría de los casos, el campo de descripción en esta consola te da una idea sobre la razón del error. ¿Cuál es el nombre de esta consola?",
    "options": [
      {
        "id": "A",
        "text": "Terminal"
      },
      {
        "id": "B",
        "text": "Dart Analysis"
      },
      {
        "id": "C",
        "text": "Run"
      },
      {
        "id": "D",
        "text": "Hot Reload"
      }
    ],
    "correctOptionId": "B",
    "explanation": "La consola 'Dart Analysis' es la herramienta integrada en Android Studio y otros IDEs que muestra errores, advertencias y sugerencias de código en tiempo real para proyectos Dart y Flutter. Proporciona información detallada sobre problemas sintácticos y semánticos, incluyendo la ubicación precisa del error y sugerencias para solucionarlo. Es una herramienta esencial para el desarrollo eficiente en Flutter.",
    "category": "Configuración"
  },
  {
    "id": "197",
    "text": "Firebase ofrece dos soluciones de bases de datos basadas en la nube y accesibles desde el cliente. ¿Cuál de las siguientes opciones es un tipo de base de datos de Firebase?",
    "options": [
      {
        "id": "A",
        "text": "SQL y MySQL"
      },
      {
        "id": "B",
        "text": "Realtime Database y Cloud Firestore"
      },
      {
        "id": "C",
        "text": "Cloud Firestore y MySQL"
      },
      {
        "id": "D",
        "text": "Realtime Database y SQL"
      }
    ],
    "correctOptionId": "B",
    "explanation": "Firebase ofrece dos soluciones principales de bases de datos: Realtime Database y Cloud Firestore. Ambas son bases de datos NoSQL basadas en la nube que permiten almacenar y sincronizar datos en tiempo real entre clientes. Realtime Database es la solución original, mientras que Cloud Firestore es una versión más nueva con características mejoradas como consultas más potentes, mejor escalabilidad y una estructura de datos más intuitiva basada en colecciones y documentos.",
    "category": "Firebase"
  },
  {
    "id": "198",
    "text": "Al configurar tu aplicación Android en el sitio web de Firebase, debes descargar el archivo google-services.json desde el sitio web de Firebase y añadirlo a los archivos de tu aplicación Android. Selecciona la mejor respuesta de las siguientes opciones: ¿Cuál es el papel principal de este archivo para tu aplicación?",
    "options": [
      {
        "id": "A",
        "text": "Este archivo de configuración incluye los ajustes de conexión https entre tu aplicación Android y los servicios de Firebase."
      },
      {
        "id": "B",
        "text": "Este archivo incluye tu nombre de usuario y contraseña para el sitio web de Firebase."
      },
      {
        "id": "C",
        "text": "El papel de este archivo es importar las últimas actualizaciones de seguridad desde el sitio web de Firebase a los usuarios de la aplicación."
      },
      {
        "id": "D",
        "text": "Este archivo comprueba si el dispositivo del usuario de la aplicación tiene conexión a Internet cada vez que el usuario inicia la aplicación."
      }
    ],
    "correctOptionId": "A",
    "explanation": "El archivo google-services.json contiene toda la configuración y credenciales necesarias para conectar tu aplicación Android con los servicios de Firebase. Incluye información como la clave de API, ID del proyecto, ID de la aplicación, y otros ajustes de configuración que permiten que tu aplicación se autentique y comunique de forma segura con los servicios de Firebase a través de conexiones HTTPS. Este archivo es esencial para integrar cualquier servicio de Firebase (como Authentication, Cloud Firestore, Analytics, etc.) en tu aplicación Android.",
    "category": "Firebase"
  }
]
